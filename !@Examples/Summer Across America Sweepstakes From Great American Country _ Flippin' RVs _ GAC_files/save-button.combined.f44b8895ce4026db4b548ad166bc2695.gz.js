(function(win, undef) {

    win.boxContextLoaded(function(jQuery) {

        var $ = jQuery;

        var AUTH_SCOPE = 'AUTH';
        var AUTH_DEBUG = SNI.BOX.DEBUG.forScope(AUTH_SCOPE, 'GIGYA');

        var SCHEME_NAME = 'gigya';
        var EVENT = 'box-gigya-events';
        var REQUIRE_LOGIN_EVENT = EVENT + '.requireLogin';

        var PARAM_UID = "gigyaUserId";
        var PARAM_TIMESTAMP = "signatureTimestamp";
        var PARAM_UID_SIGNATURE = "uidSignature";

        var EVENT_PROPERTY_UID = "UID";
        var EVENT_PROPERTY_SIGNATURE_TIMESTAMP = "signatureTimestamp";
        var EVENT_PROPERTY_UID_SIGNATURE = "UIDSignature";

        var isGigyaInitialized = false;

        var isAuthenticationChecking = false;
        var isAuthenticationChecked = false;
        var isAuthenticated = false;
        var accountEventObj = { };

        var PRIVATE_EVENTS = { };
        PRIVATE_EVENTS.LOGOUT = 'logout';
        PRIVATE_EVENTS.LOGIN = 'login';

        // can be invoked with event objects generated through Gigya's 'onLogin' or 'onLogout' events,
        // or through gigya.accounts.getAccountInfo
        // The purpose of this method is to update the private "isAuthenticationChecked", "accountEventObj" and "isAuthenticated" variables.
        var updateAuthenticatedStatus = function(eventObj) {

            AUTH_DEBUG("updating authenticated status with: ", eventObj);

            if(eventObj !== undef && eventObj.UID !== undef && eventObj.UID !== "") {
                isAuthenticated = true;
            } else {
                isAuthenticated = false;
            }
            isAuthenticationChecked = true;
            accountEventObj = eventObj;

            return {
                'isAuthenticated': isAuthenticated,
                'accountEventObj': accountEventObj
            };
        };

        var checkAuthentication = function() {

            isAuthenticationChecking = true;

            // we use getAccountInfo to make use of the API response cache generated by global header
            win.gigya.accounts.getAccountInfo({
                'callback': updateAuthenticatedStatus
                // 'cacheTimeout': 3600000 // 1 hour - commenting this out because it's cached between page loads.. breaking reconciliation
            });
        };

        var initializeGigya = function() {

            isGigyaInitialized = true;

            // connect the gigya 'onLogin' event to the private 'login' event
            win.gigya.socialize.addEventHandlers({
                'onLogin': function(eventObj) {

                    AUTH_DEBUG("Gigya service fired onLogin callback");

                    $(PRIVATE_EVENTS).trigger(PRIVATE_EVENTS.LOGIN, [updateAuthenticatedStatus(eventObj)]);
                }
            });

            // connect the gigya 'onLogout' event to the private 'logout' event
            win.gigya.socialize.addEventHandlers({
                'onLogout': function(eventObj) {

                    AUTH_DEBUG("Gigya service fired onLogout callback");

                    $(PRIVATE_EVENTS).trigger(PRIVATE_EVENTS.LOGOUT, [updateAuthenticatedStatus(eventObj)]);
                }
            });
        };

        var gigyaScheme = win.SNI.BOX.AUTH.registerAuthenticationScheme(SCHEME_NAME, {

            'isAuthenticated': function() {
                return isAuthenticated;
            },
            'requireLogin': function() {

                var gigyaScheme = this;

                $(gigyaScheme).one(REQUIRE_LOGIN_EVENT, function() {
                    throw new Error("No implementation was found for requireLogin!");
                }).trigger(REQUIRE_LOGIN_EVENT, arguments);
            },
            'isReady': function() {

                if(win.gigya === undef) {
                    return false;
                }

                if(isGigyaInitialized === false) {
                    initializeGigya();
                }

                if(isAuthenticationChecking === false && isAuthenticationChecked === false) {
                    checkAuthentication();
                }

                return typeof win.gigya !== undef && isAuthenticationChecked !== false;
            },
            'onLogin': function(callback) {

                // add the specified callback to the handler list for the private LOGIN event
                $(PRIVATE_EVENTS).on(PRIVATE_EVENTS.LOGIN, callback.bind(this));
            },
            'onLogout': function(callback) {

                // add the specified callback to the handler list for the private LOGOUT event
                $(PRIVATE_EVENTS).on(PRIVATE_EVENTS.LOGOUT, callback.bind(this));
            },
            'signUrl': function(url) {

                if(isAuthenticated === false) {
                    throw new Error("Cannot sign url, user is not logged in!");
                }

                if(!url) {
                    return url;
                }

                var uid = accountEventObj[EVENT_PROPERTY_UID];
                var signatureTimestamp = accountEventObj[EVENT_PROPERTY_SIGNATURE_TIMESTAMP];
                var uidSignature = accountEventObj[EVENT_PROPERTY_UID_SIGNATURE];

                if(SNI.BOX.Util.getQueryParamByName(url, PARAM_UID) === null) {
                    url = SNI.BOX.Util.appendParam(url, PARAM_UID, uid);
                }

                if(SNI.BOX.Util.getQueryParamByName(url, PARAM_TIMESTAMP) === null) {
                    url = SNI.BOX.Util.appendParam(url, PARAM_TIMESTAMP, signatureTimestamp);
                }

                if(SNI.BOX.Util.getQueryParamByName(url, PARAM_UID_SIGNATURE) === null) {
                    url = SNI.BOX.Util.appendParam(url, PARAM_UID_SIGNATURE, uidSignature);
                }

                return url;
            },
            'unSignUrl': function(url) {
                url = SNI.BOX.Util.removeParam(url, PARAM_UID);
                url = SNI.BOX.Util.removeParam(url, PARAM_TIMESTAMP);
                url = SNI.BOX.Util.removeParam(url, PARAM_UID_SIGNATURE);
                return url;
            }
        });
    });

})(window, undefined);
window.boxContextLoaded(function(jQuery) {

    var $ = jQuery;

    var gigyaScheme = SNI.BOX.AUTH.getSchemeByName('gigya');

    if(gigyaScheme !== null) {
        $(gigyaScheme).on('box-gigya-events.requireLogin', function(e, data) {
            
            // HGTV-specific implementation of the requireLogin method    
            if(data !== undefined && data.state !== undefined && data.state === 'register') {
                require('jquery')(window).trigger('hgtv-gigya-events.register');
            } else {

                require('jquery')(window).trigger('hgtv-gigya-events.login');
            }
            

            e.stopImmediatePropagation();
        });
    }
});/*
 * RoyalSlider
 *
 * @version 9.4.92:
 *
 * Copyright 2011-2013, Dmitry Semenov
 *
 */
window.boxContextLoaded(function(jQuery) {
   var $ = jQuery;

	//"use strict";

	if(!$.recipeBoxRsModules) {
		$.recipeBoxRsModules = {uid:0};
	}

	function RoyalSlider(element, options) {
		var i,
			self = this,
			ua = navigator.userAgent.toLowerCase();

		self.uid = $.recipeBoxRsModules.uid++;
		self.ns = '.rs' + self.uid; // unique namespace for events

		// feature detection, some ideas taken from Modernizr
		var tempStyle = document.createElement('div').style,
			vendors = ['webkit','Moz','ms','O'],
			vendor = '',
			lastTime = 0,
			tempV;

		for (i = 0; i < vendors.length; i++ ) {
			tempV = vendors[i];
			if (!vendor && (tempV + 'Transform') in tempStyle ) {
				vendor = tempV;
			}
			tempV = tempV.toLowerCase();

			if(!window.requestAnimationFrame) {
				window.requestAnimationFrame = window[tempV+'RequestAnimationFrame'];
				window.cancelAnimationFrame = window[tempV+'CancelAnimationFrame'] || window[tempV+'CancelRequestAnimationFrame'];
			}
		}

		// requestAnimationFrame polyfill by Erik MÃ¶ller
		// fixes from Paul Irish and Tino Zijdel
		if (!window.requestAnimationFrame) {
			window.requestAnimationFrame = function(callback, element) {
				var currTime = new Date().getTime(),
					timeToCall = Math.max(0, 16 - (currTime - lastTime)),
					id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
					lastTime = currTime + timeToCall;
				return id;
			};
		}

		if (!window.cancelAnimationFrame) {
			window.cancelAnimationFrame = function(id) { clearTimeout(id); };
		}


		self.isIPAD = ua.match(/(ipad)/);


		// browser UA sniffing, sadly still required
		var uaMatch = function( ua ) {
			var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
				/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
				/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
				/(msie) ([\w.]+)/.exec( ua ) ||
				ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
				[];

			return {
				browser: match[ 1 ] || "",
				version: match[ 2 ] || "0"
			};
		};
		var matched = uaMatch( ua );
		var br = {};
		if ( matched.browser ) {
			br[ matched.browser ] = true;
			br.version = matched.version;
		}

		if(br.chrome) {
			br.webkit = true;
		}

		self._browser = br;
		self.isAndroid = ua.indexOf("android") > -1;



		self.slider = $(element); // DOM reference
		self.ev = $(self); // event object
		self._doc = $(document);
		self.st = $.extend({}, $.fn.recipeBoxRoyalSlider.defaults, options);
		self._currAnimSpeed = self.st.transitionSpeed;
		self._minPosOffset = 0;
		if(self.st.allowCSS3) {
			if((!br.webkit || self.st.allowCSS3OnWebkit) ) {
				var bT = vendor + (vendor ? 'T' : 't' );
				self._useCSS3Transitions = ( (bT + 'ransform') in tempStyle ) && ( (bT + 'ransition') in tempStyle );
				if(self._useCSS3Transitions) {
					self._use3dTransform = (vendor + (vendor ? 'P' : 'p'  ) + 'erspective') in tempStyle;
				}
			}
		}

		vendor = vendor.toLowerCase();
		self._vendorPref = '-'+vendor+'-';

		self._slidesHorizontal = (self.st.slidesOrientation === 'vertical') ? false : true;
		self._reorderProp = self._slidesHorizontal ? 'left' : 'top';
		self._sizeProp = self._slidesHorizontal ? 'width' : 'height';
		self._prevNavItemId = -1;
		self._isMove = (self.st.transitionType === 'fade') ? false : true;
		if(!self._isMove) {
			self.st.sliderDrag = false;
			self._fadeZIndex = 10;
		}
		self._opacityCSS = 'z-index:0; display:none; opacity:0;';

		self._newSlideId = 0;
		self._sPosition = 0;
		self._nextSlidePos = 0;

		// init modules
		$.each($.recipeBoxRsModules, function (helper, opts) {
			if(helper !== 'uid')
				opts.call(self);
		});

		// parse all slides
		self.slides = [];
		self._idCount = 0;
		var returnVal;
		var ts = self.st.slides ? $(self.st.slides) : self.slider.children().detach();

		ts.each(function() {
			self._parseNode(this, true);
		});

		if(self.st.randomizeSlides) {
			self.slides.sort(function() { return 0.5 - Math.random(); });
		}
		self.numSlides = self.slides.length;
		self._refreshNumPreloadImages();

		if(!self.st.startSlideId) {
			self.st.startSlideId = 0;
		} else if(self.st.startSlideId > self.numSlides - 1) {
			self.st.startSlideId = self.numSlides - 1;
		}

		self._newSlideId = self.staticSlideId = self.currSlideId = self._realId =  self.st.startSlideId;
		self.currSlide = self.slides[self.currSlideId];

		self._accelerationPos = 0;
		self.msTouch = false;
		self.slider.addClass( (self._slidesHorizontal ? 'rsHor' : 'rsVer') + (self._isMove ? '' : ' rsFade') );

		var sliderHTML = '<div class="rsOverflow"><div class="rsContainer">';
		self.slidesSpacing = self.st.slidesSpacing;
		self._slideSize = ( self._slidesHorizontal ? self.slider.width() : self.slider.height() ) + self.st.slidesSpacing;

		self._preload = Boolean(self._numPreloadImages > 0);

		if(self.numSlides <= 1) {
			self._loop = false;
		}
		var loopHelpers = (self._loop && self._isMove) ? ( self.numSlides === 2 ? 1 : 2) : 0;
		self._loopHelpers = loopHelpers;

		self._maxImages = self.numSlides < 6 ? self.numSlides : 6;
		self._currBlockIndex = 0;


		self._idOffset = 0;
		self.slidesJQ = [];

		for(i =0; i < self.numSlides; i++) {
			self.slidesJQ.push( $(createItemHTML(i)) );
		}
		self._sliderOverflow = sliderHTML = $(sliderHTML + '</div></div>');


		var addCursors = function() {
			if(self.st.sliderDrag) {
				self._hasDrag = true;
				if (br.msie || br.opera) {
					self._grabCursor = self._grabbingCursor = "move";
				} else if(br.mozilla) {
					self._grabCursor = "-moz-grab";
					self._grabbingCursor = "-moz-grabbing";
				} else if(br.webkit && (navigator.platform.indexOf("Mac")!=-1)) {
					self._grabCursor = "-webkit-grab";
					self._grabbingCursor = "-webkit-grabbing";
				}
				self._setGrabCursor();
			}
		};
		var rsNS = self.ns;
		var addEventNames = function(pref, down, move, up, cancel) {
			self._downEvent = pref + down + rsNS;
			self._moveEvent = pref + move + rsNS;
			self._upEvent = pref + up + rsNS;
			if(cancel)
				self._cancelEvent = pref + cancel + rsNS;
		};


		// ie10
		self.msEnabled = window.navigator.msPointerEnabled;

		if(self.msEnabled) {
			self.msTouch = Boolean(window.navigator.msMaxTouchPoints > 1);
			self.hasTouch = false;
			self._lastItemFriction = 0.2;

			addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
		} else {
			addEventNames('mouse', 'down', 'move', 'up', 'up');

			if('ontouchstart' in window || 'createTouch' in document) {
				self.hasTouch = true;
				self._downEvent += ' touchstart' + rsNS;
				self._moveEvent += ' touchmove' + rsNS;
				self._upEvent += ' touchend' + rsNS;
				self._cancelEvent += ' touchcancel' + rsNS;
				self._lastItemFriction = 0.5;
				if(self.st.sliderTouch) {
					self._hasDrag = true;
				}
			} else {
				self.hasTouch = false;
				self._lastItemFriction = 0.2;
			}
		}
		addCursors();

		self.slider.html(sliderHTML);


		self._controlsContainer = self.st.controlsInside ? self._sliderOverflow : self.slider;

		self._slidesContainer = self._sliderOverflow.children('.rsContainer');
		if(self.msEnabled) {
			self._slidesContainer.css('-ms-touch-action', self._slidesHorizontal ? 'pan-y' : 'pan-x');
		}
		self._preloader = $('<div class="rsPreloader"></div>');
		var slides = self._slidesContainer.children('.rsSlide');

		self._currHolder = self.slidesJQ[self.currSlideId];
		self._selectedSlideHolder = 0;

		function createItemHTML(i, className) {
			return '<div style="'+ (self._isMove ? '' : (i !== self.currSlideId  ? self._opacityCSS : 'z-index:0;') ) +'" class="rsSlide '+ (className || '')+'"></div>';
		}

		if(self._useCSS3Transitions) {

			// some constants for CSS3
			self._TP = 'transition-property';
			self._TD = 'transition-duration';
			self._TTF = 'transition-timing-function';

			self._yProp = self._xProp = self._vendorPref +'transform';

			if(self._use3dTransform) {
				if(br.webkit && !br.chrome) {
					self.slider.addClass('rsWebkit3d');
				}
				if((/iphone|ipad|ipod/gi).test(navigator.appVersion)) {

				}

				self._tPref1 = 'translate3d(';
				self._tPref2 = 'px, ';
				self._tPref3 = 'px, 0px)';
			} else {
				self._tPref1 = 'translate(';
				self._tPref2 = 'px, ';
				self._tPref3 = 'px)';
			}
			if(!self._isMove) {
				var animObj = {};
				animObj[(self._vendorPref + self._TP)] = 'opacity';
				animObj[(self._vendorPref + self._TD)] = self.st.transitionSpeed + 'ms';
				animObj[(self._vendorPref + self._TTF)] = self.st.css3easeInOut;
				slides.css(animObj);
			} else {
				self._slidesContainer[(self._vendorPref + self._TP)] = (self._vendorPref + 'transform');
			}


		} else {
			self._xProp = 'left';
			self._yProp = 'top';
		}



		// window resize
		var resizeTimer;
		$(window).on('resize'+self.ns, function() {
			if(resizeTimer) {
				clearTimeout(resizeTimer);
			}
			resizeTimer = setTimeout(function() { self.updateSliderSize(); }, 50);
		});
		self.ev.trigger('rsAfterPropsSetup'); // navigation (bullets, thumbs...) are created here

		self.updateSliderSize();


		// keyboard nav
		if(self.st.keyboardNavEnabled) {
			self._bindKeyboardNav();
		}

		if(self.st.arrowsNavHideOnTouch && (self.hasTouch || self.msTouch) ) {
			self.st.arrowsNav = false;
		}

		//Direction navigation (arrows)
		if(self.st.arrowsNav) {
			var rArr = 'rsArrow',
				container = self._controlsContainer;
			$('<div class="'+rArr+' '+rArr+'Left"><div class="'+rArr+'Icn"></div></div><div class="'+rArr+' '+rArr+'Right"><div class="'+rArr+'Icn"></div></div>').appendTo(container);

			self._arrowLeft = container.children('.'+rArr+'Left').click(function(e) {
				e.preventDefault();
				self.prev();
			});
			self._arrowRight = container.children('.'+rArr+'Right').click(function(e) {
				e.preventDefault();
				self.next();
			});

			if(self.st.arrowsNavAutoHide && !self.hasTouch) {
				self._arrowLeft.addClass('rsHidden');
				self._arrowRight.addClass('rsHidden');

				var hoverEl = container;
				hoverEl.one("mousemove.arrowshover",function() {
					self._arrowLeft.removeClass('rsHidden');
					self._arrowRight.removeClass('rsHidden');
				});


				hoverEl.hover(
					function() {
						if(!self._arrowsAutoHideLocked) {
							self._arrowLeft.removeClass('rsHidden');
							self._arrowRight.removeClass('rsHidden');
						}
					},
					function() {
						if(!self._arrowsAutoHideLocked) {
							self._arrowLeft.addClass('rsHidden');
							self._arrowRight.addClass('rsHidden');
						}
					}
				);
			}
			self.ev.on('rsOnUpdateNav', function() {
				self._updateArrowsNav();
			});
			self._updateArrowsNav();
		}



		if( self._hasDrag ) {
			self._slidesContainer.on(self._downEvent, function(e) { self._onDragStart(e); });
		} else {
			self.dragSuccess = false;
		}
		var videoClasses = ['rsPlayBtnIcon', 'rsPlayBtn', 'rsCloseVideoBtn', 'rsCloseVideoIcn'];
		self._slidesContainer.click(function(e) {
			if(!self.dragSuccess) {
				var t = $(e.target);
				var tClass = t.attr('class');
				if( $.inArray(tClass, videoClasses) !== -1) {
					if( self.toggleVideo() ) {
						return false;
					}
				}
				if(self.st.navigateByClick && !self._blockActions) {
					if($(e.target).closest('.rsNoDrag', self._currHolder).length) {
						return true;
					}
					self._mouseNext(e);
				}
				self.ev.trigger('rsSlideClick');
			}
		}).on('click.rs', 'a', function(e) {
			if(self.dragSuccess) {
				return false;
			} else {
				self._blockActions = true;
				//e.stopPropagation();
				//e.stopImmediatePropagation();
				setTimeout(function() {
					self._blockActions = false;
				}, 3);
			}
		});
		self.ev.trigger('rsAfterInit');
	} /* RoyalSlider Constructor End */

	/**
	 *
	 * RoyalSlider Core Prototype
	 *
	 */
	RoyalSlider.prototype = {
		constructor: RoyalSlider,
		_mouseNext: function(e) {
			var self = this,
				relativePos = e[self._slidesHorizontal ? 'pageX' : 'pageY'] - self._sliderOffset;

			if(relativePos >= self._nextSlidePos) {
				self.next();
			} else if(relativePos < 0) {
				self.prev();
			}
		},
		_refreshNumPreloadImages: function() {
			var self = this,
				n;
			n = self.st.numImagesToPreload;
			self._loop = self.st.loop;

			if(self._loop) {
				if(self.numSlides === 2) {
					self._loop = false;
					self.st.loopRewind = true;
				} else if(self.numSlides < 2) {
					self.st.loopRewind = self._loop = false;
				}

			}
			if(self._loop && n > 0) {
				if(self.numSlides <= 4) {
					n = 1;
				} else {
					if(self.st.numImagesToPreload > (self.numSlides - 1) / 2 ) {
						n = Math.floor( (self.numSlides - 1) / 2 );
					}
				}
			}
			self._numPreloadImages = n;
		},
		_parseNode: function(content, pushToSlides) {
			var self = this,
				hasImg,
				isRoot,
				hasCover,
				obj = {},
				tempEl,
				first = true;
			content = $(content);
			self._currContent = content;
			self.ev.trigger('rsBeforeParseNode', [content, obj]);
			if(obj.stopParsing) {
				return;
			}
			content = self._currContent;
			obj.id = self._idCount;
			obj.contentAdded = false;
			self._idCount++;
			obj.images = [];
			obj.isBig = false;

			if(!obj.hasCover) {
				if(content.hasClass('rsImg')) {
					tempEl = content;
					hasImg = true;
				} else {
					tempEl = content.find('.rsImg');
					if(tempEl.length) {
						hasImg = true;
					}
				}

				if(hasImg) {
					obj.bigImage = tempEl.eq(0).attr('data-rsBigImg');
					tempEl.each(function() {
						var item = $(this);
						if(item.is('a')) {
							parseEl(item, 'href');
						} else if(item.is('img')) {
							parseEl(item, 'src');
						} else {
							parseEl(item);
						}
					});
				} else if(content.is('img')) {
					content.addClass('rsImg rsMainSlideImage');
					parseEl(content, 'src');
				}
			}
			tempEl = content.find('.rsCaption');
			if(tempEl.length) {
				obj.caption = tempEl.remove();
			}
			obj.content = content;

			self.ev.trigger('rsAfterParseNode', [content, obj]);
			function parseEl(el, s) {
				if(s) {
					obj.images.push( el.attr(s) );
				} else {
					obj.images.push( el.text() );
				}
				if(first) {
					first = false;
					obj.caption = (s === 'src') ? el.attr('alt') : el.contents();
					obj.image = obj.images[0];
					obj.videoURL = el.attr('data-rsVideo');


					var wAtt = el.attr('data-rsw'),
						hAtt = el.attr('data-rsh');
					if (typeof wAtt !== 'undefined' && wAtt !== false && typeof hAtt !== 'undefined' && hAtt !== false ) {
						obj.iW = parseInt(wAtt, 10);
						obj.iH = parseInt(hAtt, 10);
					} else if(self.st.imgWidth && self.st.imgHeight ) {
						obj.iW = self.st.imgWidth;
						obj.iH = self.st.imgHeight;
					}
				}
			}
			if(pushToSlides) {
				self.slides.push(obj);
			}
			if(obj.images.length === 0) {
				obj.isLoaded = true;
				obj.isRendered = false;
				obj.isLoading = false;
				obj.images = null;
			}
			return obj;
		},
		_bindKeyboardNav: function() {
			var self = this,
				interval,
				keyCode,
				onKeyboardAction = function (keyCode) {
					if(keyCode === 37) {
						self.prev();
					} else if (keyCode === 39) {
						self.next();
					}
				};

			self._doc.on('keydown' + self.ns, function(e) {
				if(!self._isDragging) {
					keyCode = e.keyCode;
					if(keyCode === 37 || keyCode === 39) {
						if(!interval) {
							onKeyboardAction(keyCode);
							interval = setInterval(function() {
								onKeyboardAction(keyCode);
							}, 700);
						}
					}
				}
			}).on('keyup' + self.ns, function(e) {
				if(interval) {
					clearInterval(interval);
					interval = null;
				}
			});



		},




		goTo: function(id, notUserAction) {
			var self = this;
			if(id !== self.currSlideId) {
				self._moveTo(id,self.st.transitionSpeed, true, !notUserAction);
			}
		},
		destroy: function(remove) {
			var self = this;
			self.ev.trigger('rsBeforeDestroy');
			self._doc.off('keydown' +self.ns+ ' keyup' + self.ns + ' ' + self._moveEvent +' '+ self._upEvent );
			self._slidesContainer.off(self._downEvent + ' click');
			self.slider.data('royalSlider', null);
			$.removeData(self.slider, 'royalSlider');
			$(window).off('resize' + self.ns);
			if(remove) {
				self.slider.remove();
			}
			self.slides = null;
			self.slider = null;
			self.ev = null;
		},
		_updateBlocksContent: function(beforeTransition, getId) {
			var self = this,
				item,
				i,
				n,
				pref,
				group,
				groupId,
				slideCode,
				loop = self._loop,
				numSlides = self.numSlides;
			if(!isNaN(getId) ) {
				return getCorrectLoopedId(getId);
			}


			var id = self.currSlideId;
			var groupOffset;

			var itemsOnSide = beforeTransition ? (Math.abs(self._prevSlideId - self.currSlideId) >= self.numSlides - 1 ? 0 : 1) : self._numPreloadImages;
			var itemsToCheck = Math.min(2, itemsOnSide);

			var updateAfter = false;
			var updateBefore = false;
			var tempId;



			for(i = id; i < id + 1 + itemsToCheck; i++) {
				tempId = getCorrectLoopedId(i);
				item = self.slides[tempId];
				if(item && (!item.isAdded || !item.positionSet) ) {
					updateAfter = true;
					break;
				}
			}
			for(i = id - 1; i > id - 1 - itemsToCheck; i--) {
				tempId = getCorrectLoopedId(i);
				item = self.slides[tempId];
				if(item && (!item.isAdded || !item.positionSet) ) {
					updateBefore = true;
					break;
				}
			}
			if(updateAfter) {
				for(i = id; i < id + itemsOnSide + 1; i++) {
					tempId = getCorrectLoopedId(i);
					groupOffset = Math.floor( (self._realId - (id - i)) / self.numSlides) * self.numSlides;
					item = self.slides[tempId];
					if(item) {
						updateItem(item, tempId);
					}
				}
			}
			if(updateBefore) {
				for(i = id - 1; i > id - 1 - itemsOnSide; i--) {
					tempId = getCorrectLoopedId(i);
					groupOffset = Math.floor( (self._realId - (id - i) ) / numSlides) * numSlides;
					item = self.slides[tempId];
					if(item) {
						updateItem(item, tempId);
					}
				}
			}
			if(!beforeTransition) {
				var start = id;
				var distance = itemsOnSide;
				var min = getCorrectLoopedId(id - itemsOnSide);
				var max = getCorrectLoopedId(id + itemsOnSide);

				var nmin = min > max ? 0 : min;

				for (i = 0; i < numSlides; i++) {
					if(min > max) {
						if(i > min - 1) {
							continue;
						}
					}
					if(i < nmin || i > max) {
						item = self.slides[i];
						if(item && item.holder) {
							item.holder.detach();
							item.isAdded = false;
						}
					}
				}
			}





			function updateItem(item , i, slideCode) {

				if(!item.isAdded) {
					if(!slideCode)
						slideCode = self.slidesJQ[i];

					if(!item.holder) {
						slideCode = self.slidesJQ[i] = $(slideCode);
						item.holder = slideCode;
					} else {
						slideCode = item.holder;
					}

					item.appendOnLoaded = false;


					updatePos(i, item, slideCode);
					addContent(i, item);
					self._addBlockToContainer(item, slideCode, beforeTransition);
					item.isAdded = true;
				} else {
					addContent(i, item);
					updatePos(i, item);
				}
			}
			function addContent(i, item) {
				if(!item.contentAdded) {
					self.setItemHtml(item, beforeTransition);
					if(!beforeTransition) {
						item.contentAdded = true;
					}

				}
			}
			function updatePos(i, item, slideCode) {
				if(self._isMove) {
					if(!slideCode) {
						slideCode = self.slidesJQ[i];
					}

					slideCode.css(self._reorderProp, (i + self._idOffset + groupOffset) * self._slideSize);
				}
			}
			function getCorrectLoopedId(index) {
				var changed = false;
				if(loop) {
					if(index > numSlides - 1) {
						return getCorrectLoopedId(index - numSlides);
					} else  if(index < 0) {
						return getCorrectLoopedId(numSlides + index);
					}
				}
				return index;
			}

		},

		/**
		 * Sets or loads HTML for specified slide
		 * @param {Object} currSlideObject  holds data about curr slide (read about rsAfterParseNode for more info)
		 * @param {Boolean} beforeTransition determines if setItemHTML method is called before or after transition
		 */
		setItemHtml: function(currSlideObject, beforeTransition) {
			var self = this;

			var parseDataAndLoad = function() {
				if(!currSlideObject.images) {
					currSlideObject.isRendered = true;
					currSlideObject.isLoaded = true;
					currSlideObject.isLoading = false;
					appendContent(true);
					return;
				}
				if(currSlideObject.isLoading) {
					return;
				}

				var el,
					isRoot;
				if(currSlideObject.content.hasClass('rsImg') ) {
					el = currSlideObject.content;
					isRoot = true;
				} else {
					el = currSlideObject.content.find('.rsImg:not(img)');
				}
				if(el && !el.is('img')) {
					el.each(function() {
						var item = $(this),
							newEl = '<img class="rsImg" src="'+ ( item.is('a') ? item.attr('href') : item.text() ) +'" />';

						if(!isRoot) {
							item.replaceWith( newEl );
						} else {
							currSlideObject.content = $(newEl);
						}
					});
				}

				el = isRoot ? currSlideObject.content : currSlideObject.content.find('img.rsImg');
				setPreloader();

				el.eq(0).addClass('rsMainSlideImage');
				if(currSlideObject.iW && currSlideObject.iH) {
					if(!currSlideObject.isLoaded) {
						self._resizeImage( currSlideObject );
					}
					appendContent();
				}

				currSlideObject.isLoading = true;
				var newEl;

				var eNames = 'load.rs error.rs';
				if(currSlideObject.isBig) {
					$('<img />').on(eNames, function(e){
						$(this).off(eNames);
						onLoad( [this], true );
					}).attr('src', currSlideObject.image);
				} else {
					currSlideObject.loaded = [];
					currSlideObject.numStartedLoad = 0;
					var onLoaded = function(e) {
						$(this).off(eNames);
						currSlideObject.loaded.push( this );
						if(currSlideObject.loaded.length === currSlideObject.numStartedLoad) {
							onLoad( currSlideObject.loaded, false );
						}
					};
					for(var i = 0; i < currSlideObject.images.length; i++) {
						var image = $('<img />');
						currSlideObject.numStartedLoad++;
						image.on('load.rs error.rs', onLoaded).attr('src', currSlideObject.images[i]);
					}
				}
			};

			var onLoad = function($images, isBig) {
				if($images.length) {
					var img = $images[0],
					src = img.src;

					if(isBig !== currSlideObject.isBig) {
						var c = currSlideObject.holder.children();
						if(c && c.length > 1) {
							removePreloader();
						}
						return;
					}

					if(currSlideObject.iW && currSlideObject.iH) {
						imageLoadingComplete();
						return;
					}
					currSlideObject.iW = img.width;
					currSlideObject.iH = img.height;
					if(currSlideObject.iW && currSlideObject.iH) {
						imageLoadingComplete();
						return;
					} else {
						// if no size, try again
						var loader = new Image();
						loader.onload = function() {
							if(loader.width) {
								currSlideObject.iW = loader.width;
								currSlideObject.iH = loader.height;
								imageLoadingComplete();
							} else {
								setTimeout(function() {
									if(loader.width) {
										currSlideObject.iW = loader.width;
										currSlideObject.iH = loader.height;
									}

									// failed to get size on last tier, just output image
									imageLoadingComplete();
								}, 1000);
							}
						};
						loader.src = img.src;
					}
				} else {
					imageLoadingComplete();
				}
			};

			var imageLoadingComplete = function () {
				currSlideObject.isLoaded = true;
				currSlideObject.isLoading = false;

				appendContent();
				removePreloader();
				triggerLoaded();
			};

			var waitForTransition = function () {
				if(!self._isMove && currSlideObject.images && currSlideObject.iW && currSlideObject.iH) {
					parseDataAndLoad();
					return;
				}
				currSlideObject.holder.isWaiting = true;
				setPreloader();
				currSlideObject.holder.slideId = -99;
			};

			var appendContent = function() {
				if(!currSlideObject.isAppended && self.ev) {

					var visibleNearby = self.st.visibleNearby,
					bId = currSlideObject.id - self._newSlideId;
					if(!beforeTransition && !currSlideObject.appendOnLoaded && self.st.fadeinLoadedSlide  && ( bId === 0 || ( (visibleNearby || self._isAnimating || self._isDragging) && (bId === -1 || bId === 1) ) ) ) {
						var css = {
							visibility: 'visible',
							opacity: 0
						};
						css[self._vendorPref + 'transition'] = 'opacity 400ms ease-in-out';
						currSlideObject.content.css(css);

						setTimeout(function() {
							currSlideObject.content.css('opacity', 1);
						}, 16);
					}

					if(currSlideObject.holder.find('.rsPreloader').length) {
						currSlideObject.holder.append( currSlideObject.content );
					} else {
						currSlideObject.holder.html( currSlideObject.content );
					}


					currSlideObject.isAppended = true;
					if(currSlideObject.isLoaded) {
						self._resizeImage(currSlideObject);
						triggerLoaded();
					}
					if(!currSlideObject.sizeReady) {
						currSlideObject.sizeReady = true;
						setTimeout(function() {
							// triggers after content is added, usually is true when page is refreshed from cache
							self.ev.trigger('rsMaybeSizeReady', currSlideObject);
						}, 100);
					}

				}
			};
			var triggerLoaded = function () {
				if(!currSlideObject.loadedTriggered && self.ev) {
					currSlideObject.isLoaded = currSlideObject.loadedTriggered = true;
					currSlideObject.holder.trigger('rsAfterContentSet');
					self.ev.trigger('rsAfterContentSet', currSlideObject);
				}
			};
			var setPreloader = function () {
				if(self.st.usePreloader)
					currSlideObject.holder.html(self._preloader.clone());
			};
			var removePreloader = function (now) {
				if(self.st.usePreloader) {
					var preloader = currSlideObject.holder.find('.rsPreloader');
					if(preloader.length) {
						preloader.remove();
					}
				}
			};

			if(currSlideObject.isLoaded) {
				appendContent();
				return;
			} else {
				if(beforeTransition) {
					waitForTransition();
				} else {
					parseDataAndLoad();
				}
			}

		},
		_addBlockToContainer: function(slideObject, content, dontFade) {
			var self = this;
			var holder = slideObject.holder;
			var bId = slideObject.id - self._newSlideId;
			var visibleNearby = false;

			self._slidesContainer.append(holder);
			slideObject.appendOnLoaded = false;
		},

		_onDragStart:function(e, isThumbs) {
			var self = this,
				point,
				wasAnimating,
				isTouch = (e.type === 'touchstart');


			self._isTouchGesture = isTouch;

			self.ev.trigger('rsDragStart');
			if($(e.target).closest('.rsNoDrag', self._currHolder).length) {
				self.dragSuccess = false;
				return true;
			}


			if(!isThumbs) {
				if(self._isAnimating) {
					self._wasAnimating = true;

					self._stopAnimation();
				}
			}
			self.dragSuccess = false;
			if(self._isDragging) {
				if(isTouch) {
					self._multipleTouches = true;
				}
				return;
			} else {
				if(isTouch) {
					self._multipleTouches = false;
				}
			}

			self._setGrabbingCursor();

			if(isTouch) {
				//parsing touch event
				var touches = e.originalEvent.touches;
				if(touches && touches.length > 0) {
					point = touches[0];
					if(touches.length > 1) {
						self._multipleTouches = true;
					}
				}
				else {
					return;
				}
			} else {
				e.preventDefault();
				point = e;
				if(self.msEnabled) point = point.originalEvent;
			}

			self._isDragging = true;
			self._doc.on(self._moveEvent, function(e) { self._onDragMove(e, isThumbs); })
						.on(self._upEvent, function(e) { self._onDragRelease(e, isThumbs); });

			self._currMoveAxis = '';
			self._hasMoved = false;
			self._pageX = point.pageX;
			self._pageY = point.pageY;
			self._startPagePos = self._accelerationPos = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal) ? point.pageX : point.pageY;

			self._horDir = 0;
			self._verDir = 0;

			self._currRenderPosition = !isThumbs ? self._sPosition : self._thumbsPosition;

			self._startTime = new Date().getTime();
			if(isTouch) {
				self._sliderOverflow.on(self._cancelEvent, function(e) { self._onDragRelease(e, isThumbs); });
			}
		},
		_renderMovement:function(point, isThumbs) {
			var self = this;
			if(self._checkedAxis) {

				var timeStamp = self._renderMoveTime,
					deltaX = point.pageX - self._pageX,
					deltaY = point.pageY - self._pageY,
					newX = self._currRenderPosition + deltaX,
					newY = self._currRenderPosition + deltaY,
					isHorizontal = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal),
					newPos = isHorizontal ? newX : newY,
					mAxis = self._currMoveAxis;

				self._hasMoved = true;
				self._pageX = point.pageX;
				self._pageY = point.pageY;

				if(mAxis === 'x' && deltaX !== 0) {
					self._horDir = deltaX > 0 ? 1 : -1;
				} else if(mAxis === 'y' && deltaY !== 0) {
					self._verDir = deltaY > 0 ? 1 : -1;
				}

				var pointPos = isHorizontal ? self._pageX : self._pageY,
					deltaPos = isHorizontal ? deltaX : deltaY;
				if(!isThumbs) {
					if(!self._loop) {
						if(self.currSlideId <= 0) {
							if(pointPos - self._startPagePos > 0) {
								newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
							}
						}
						if(self.currSlideId >= self.numSlides - 1) {
							if(pointPos - self._startPagePos < 0) {
								newPos = self._currRenderPosition + deltaPos * self._lastItemFriction ;
							}
						}
					}
				} else {
					if(newPos > self._thumbsMinPosition) {
						newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
					} else if(newPos < self._thumbsMaxPosition) {
						newPos = self._currRenderPosition + deltaPos * self._lastItemFriction ;
					}
				}

				self._currRenderPosition = newPos;

				if (timeStamp - self._startTime > 200) {
					self._startTime = timeStamp;
					self._accelerationPos = pointPos;
				}

				if(!isThumbs) {
					if(self._isMove) {
						self._setPosition(self._currRenderPosition);
					}
				} else {
					self._setThumbsPosition(self._currRenderPosition);
				}
			}

		},
		_onDragMove:function(e, isThumbs) {
			var self = this,
				point,
				isTouch = (e.type === 'touchmove');

			if(self._isTouchGesture && !isTouch) {
				return;
			}

			if(isTouch) {
				if(self._lockAxis) {
					return;
				}
				var touches = e.originalEvent.touches;
				if(touches) {
					if(touches.length > 1) {
						return;
					} else {
						point = touches[0];
					}
				} else {
					return;
				}
			} else {
				point = e;
				if(self.msEnabled) point = point.originalEvent;
			}


			if(!self._hasMoved) {
				if(self._useCSS3Transitions) {
					(!isThumbs ? self._slidesContainer : self._thumbsContainer).css((self._vendorPref + self._TD), '0s');
				}
				(function animloop(){
					if(self._isDragging) {
						self._animFrame = requestAnimationFrame(animloop);
						if(self._renderMoveEvent)
							self._renderMovement(self._renderMoveEvent, isThumbs);
					}

				})();
			}

			if(!self._checkedAxis) {

				var dir = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal),
					diff = (Math.abs(point.pageX - self._pageX) - Math.abs(point.pageY - self._pageY) ) - (dir ? -7 : 7);

				if(diff > 7) {
					// hor movement
					if(dir) {
						e.preventDefault();
						self._currMoveAxis = 'x';
					} else if(isTouch) {
						self._completeGesture();
						return;
					}
					self._checkedAxis = true;
				} else if(diff < -7) {
					// ver movement
					if(!dir) {
						e.preventDefault();
						self._currMoveAxis = 'y';
					} else if(isTouch) {
						self._completeGesture();
						return;
					}
					self._checkedAxis = true;
				}
				return;
			}

			e.preventDefault();
			self._renderMoveTime = new Date().getTime();
			self._renderMoveEvent = point;
		},
		_completeGesture: function() {
			var self = this;
			self._lockAxis = true;
			self._hasMoved = self._isDragging = false;
			self._onDragRelease();
		},
		_onDragRelease:function(e, isThumbs) {
			var self = this,
				totalMoveDist,
				accDist,
				duration,
				v0,
				newPos,
				newDist,
				newDuration,
				blockLink,
				isTouch = (e.type === 'touchend' || e.type === 'touchcancel');


			if(self._isTouchGesture && !isTouch) {
				return;
			}
			self._isTouchGesture = false;
			self.ev.trigger('rsDragRelease');

			self._renderMoveEvent = null;
			self._isDragging = false;
			self._lockAxis = false;
			self._checkedAxis = false;
			self._renderMoveTime = 0;
			cancelAnimationFrame(self._animFrame);
			if(self._hasMoved) {
				if(!isThumbs) {
					if(self._isMove) {
						self._setPosition(self._currRenderPosition);
					}
				} else {
					self._setThumbsPosition(self._currRenderPosition);
				}
			}


			self._doc.off(self._moveEvent).off(self._upEvent);

			if(isTouch) {
				self._sliderOverflow.off(self._cancelEvent);
			}


			self._setGrabCursor();
			if (!self._hasMoved && !self._multipleTouches) {
				if(isThumbs && self._thumbsEnabled) {
					var item = $(e.target).closest('.rsNavItem');
					if(item.length) {
						self.goTo(item.index());
					}
					return;
				}
			}
			var orient = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal);
			if(!self._hasMoved || (self._currMoveAxis === 'y' && orient) || (self._currMoveAxis === 'x' && !orient) ) {
				if(!isThumbs && self._wasAnimating) {
					self._wasAnimating = false;
					if(!self.st.navigateByClick) {
						self.dragSuccess = true;
					} else {
						self._mouseNext( (self.msEnabled ? e.originalEvent : e) );
						self.dragSuccess = true;
						return;
					}
				} else {
					self._wasAnimating = false;
					self.dragSuccess = false;
					return;
				}

			} else {
				self.dragSuccess = true;
			}

			self._wasAnimating = false;


			self._currMoveAxis = '';


			function getCorrectSpeed(newSpeed) {
				if(newSpeed < 100) {
					return 100;
				} else if(newSpeed > 500) {
					return 500;
				}
				return newSpeed;
			}
			function returnToCurrent(isSlow, v0) {
				if(self._isMove || isThumbs) {

					newPos = (-self._realId - self._idOffset) * self._slideSize;
					newDist = Math.abs(self._sPosition  - newPos);
					self._currAnimSpeed = newDist / v0;
					if(isSlow) {
						self._currAnimSpeed += 250;
					}
					self._currAnimSpeed = getCorrectSpeed(self._currAnimSpeed);

					self._animateTo(newPos, false);
				}
			}

			var snapDist = self.st.minSlideOffset,
				point = isTouch ? e.originalEvent.changedTouches[0] : (self.msEnabled ? e.originalEvent : e),
				pPos = orient ? point.pageX : point.pageY,
				sPos = self._startPagePos,
				axPos = self._accelerationPos,
				axCurrItem = self.currSlideId,
				axNumItems = self.numSlides,
				dir = orient ? self._horDir : self._verDir,
				loop = self._loop,
				changeHash = false,
				distOffset = 0;

			totalMoveDist = Math.abs(pPos - sPos);
			accDist = pPos - axPos;


			duration = (new Date().getTime()) - self._startTime;
			v0 = Math.abs(accDist) / duration;

			if(dir === 0 || axNumItems <= 1) {
				returnToCurrent(true, v0);
				return;
			}

			if(!loop && !isThumbs) {
				if(axCurrItem <= 0) {
					if(dir > 0) {
						returnToCurrent(true, v0);
						return;
					}
				} else if(axCurrItem >= axNumItems - 1) {
					if(dir < 0) {
						returnToCurrent(true, v0);
						return;
					}
				}
			}

			if(!isThumbs) {
				if(sPos + snapDist < pPos) {
					if(dir < 0) {
						returnToCurrent(false, v0);
						return;
					}
					self._moveTo('prev', getCorrectSpeed(Math.abs(self._sPosition  - (-self._realId - self._idOffset + 1) * self._slideSize) / v0), changeHash, true, true);
				} else if(sPos - snapDist > pPos) {
					if(dir > 0) {
						returnToCurrent(false, v0);
						return;
					}
					self._moveTo('next', getCorrectSpeed(Math.abs(self._sPosition  - (-self._realId - self._idOffset - 1) * self._slideSize) / v0), changeHash, true, true);
				} else {
					returnToCurrent(false, v0);
				}
			} else {
				newPos = self._thumbsPosition;
				var transitionSpeed;

				if(newPos > self._thumbsMinPosition) {
					newPos = self._thumbsMinPosition;
				} else if(newPos < self._thumbsMaxPosition) {
					newPos = self._thumbsMaxPosition;
				} else {
					var friction = 0.003,
						S = (v0 * v0) / (friction * 2),
						minXDist = -self._thumbsPosition,
						maxXDist = self._thumbsContainerSize - self._thumbsViewportSize + self._thumbsPosition;

					if (accDist > 0 && S > minXDist) {
						minXDist = minXDist + self._thumbsViewportSize / (15 / (S / v0 * friction));
						v0 = v0 * minXDist / S;
						S = minXDist;
					} else if (accDist < 0 && S > maxXDist) {
						maxXDist = maxXDist + self._thumbsViewportSize / (15 / (S / v0 * friction));
						v0 = v0 * maxXDist / S;
						S = maxXDist;
					}




					transitionSpeed =  Math.max(Math.round(v0 / friction), 50);
					newPos = newPos + S * (accDist < 0 ? -1 : 1);


					if(newPos > self._thumbsMinPosition) {
						self._animateThumbsTo(newPos, transitionSpeed, true, self._thumbsMinPosition, 200);
						return;
					} else if(newPos < self._thumbsMaxPosition) {
						self._animateThumbsTo( newPos, transitionSpeed, true, self._thumbsMaxPosition, 200);
						return;
					}
				}

				self._animateThumbsTo(newPos, transitionSpeed, true);

			}
		},
		_setPosition: function(pos) {
			var self = this;
			pos = self._sPosition = pos;
			if(self._useCSS3Transitions) {
				self._slidesContainer.css(self._xProp, self._tPref1 + ( self._slidesHorizontal ? (pos + self._tPref2 + 0) : (0 + self._tPref2 + pos) ) + self._tPref3 );
			} else {
				self._slidesContainer.css(self._slidesHorizontal ? self._xProp : self._yProp, pos);
			}
		},


		updateSliderSize: function(force) {
			var self = this,
				newWidth,
				newHeight;

			if(self.st.autoScaleSlider) {
				var asw = self.st.autoScaleSliderWidth,
					ash = self.st.autoScaleSliderHeight;

				if(self.st.autoScaleHeight) {
					newWidth = self.slider.width();
					if(newWidth != self.width) {
						self.slider.css("height", newWidth * (ash / asw) );
						newWidth = self.slider.width();
					}
					newHeight = self.slider.height();
				} else {
					newHeight = self.slider.height();
					if(newHeight != self.height) {
						self.slider.css("width", newHeight * (asw / ash));
						newHeight = self.slider.height();
					}
					newWidth = self.slider.width();
				}

			} else {
				newWidth = self.slider.width();
				newHeight = self.slider.height();
			}



			if(force || newWidth != self.width || newHeight != self.height) {
				self.width = newWidth;
				self.height = newHeight;

				self._wrapWidth = newWidth;
				self._wrapHeight = newHeight;

				self.ev.trigger('rsBeforeSizeSet');
				self.ev.trigger('rsAfterSizePropSet');

				self._sliderOverflow.css({
					width: self._wrapWidth,
					height: self._wrapHeight
				});


				self._slideSize = (self._slidesHorizontal ? self._wrapWidth : self._wrapHeight) + self.st.slidesSpacing;


				self._imagePadding = self.st.imageScalePadding;
				var item,
					slideItem,
					i,
					img;
				for(i = 0; i < self.slides.length; i++) {
					item = self.slides[i];
					item.positionSet = false;

					if(item && item.images && item.isLoaded) {
						item.isRendered = false;
						self._resizeImage(item);
					}
				}
				if(self._cloneHolders) {
					for(i = 0; i < self._cloneHolders.length; i++) {
						item = self._cloneHolders[i];
						item.holder.css(self._reorderProp, (item.id + self._idOffset) * self._slideSize);
					}
				}

				self._updateBlocksContent();

				if(self._isMove) {
					if(self._useCSS3Transitions) {
						self._slidesContainer.css(self._vendorPref + 'transition-duration', '0s');
					}
					self._setPosition( (-self._realId - self._idOffset) * self._slideSize);
				}
				self.ev.trigger('rsOnUpdateNav');
			}
			self._sliderOffset = self._sliderOverflow.offset();
			self._sliderOffset = self._sliderOffset[self._reorderProp];


		},

		/**
		 * Adds slide
		 * @param  {jQuery object or raw HTML} htmltext
		 * @param  {int} index    (optional) Index where item should be added (last item is removed of not specified)
		 */
		appendSlide: function(htmltext, index) {
			var self = this,
				parsedSlide = self._parseNode(htmltext);

			if(isNaN(index) || index > self.numSlides) {
				index = self.numSlides;
			}
			self.slides.splice(index, 0, parsedSlide);
			self.slidesJQ.splice(index, 0, '<div style="'+ (self._isMove ? 'position:absolute;' : self._opacityCSS ) +'" class="rsSlide"></div>');

			if(index < self.currSlideId) {
				self.currSlideId++;
			}
			self.ev.trigger('rsOnAppendSlide', [parsedSlide, index]);

			self._refreshSlides(index);

			if(index === self.currSlideId) {
				self.ev.trigger('rsAfterSlideChange');
			}
		},

		/**
		 * Removes slide
		 * @param  {int} Index of item that should be removed
		 */
		removeSlide: function(index) {
			var self = this,
				slideToRemove = self.slides[index];

			if(slideToRemove) {
				if(slideToRemove.holder) {
					slideToRemove.holder.remove();
				}
				if(index < self.currSlideId) {
					self.currSlideId--;
				}
				self.slides.splice(index, 1);
				self.slidesJQ.splice(index, 1);

				self.ev.trigger('rsOnRemoveSlide', [index]);
				self._refreshSlides(index);

				if(index === self.currSlideId) {
					self.ev.trigger('rsAfterSlideChange');
				}
			}
		},
		_refreshSlides: function(refreshIndex) {

			// todo: optimize this stuff
			var self = this;

			var oldNumSlides = self.numSlides;
			var numLoops = self._realId <= 0 ? 0 : Math.floor(self._realId / oldNumSlides);

			self.numSlides = self.slides.length;
			if(self.numSlides === 0) {
				self.currSlideId = self._idOffset = self._realId = 0;
				self.currSlide = self._oldHolder = null;
			} else {
				self._realId = numLoops * self.numSlides + self.currSlideId;
			}

			for(var i = 0; i < self.numSlides; i++) {
				self.slides[i].id = i;
			}

			self.currSlide = self.slides[self.currSlideId];
			self._currHolder = self.slidesJQ[self.currSlideId];

			if(self.currSlideId >= self.numSlides) {
				self.goTo(self.numSlides - 1);
			} else if(self.currSlideId < 0) {
				self.goTo(0);
			}

			self._refreshNumPreloadImages();

			if(self._isMove && self._loop) {
				self._slidesContainer.css((self._vendorPref + self._TD), '0ms');
			}
			if(self._refreshSlidesTimeout) {
				clearTimeout(self._refreshSlidesTimeout);
			}


			self._refreshSlidesTimeout = setTimeout(function() {
				if(self._isMove) {
					self._setPosition( (-self._realId - self._idOffset) * self._slideSize);
				}
				self._updateBlocksContent();
				if(!self._isMove) {
					self._currHolder.css({
						display: 'block',
						opacity: 1
					});
				}

			}, 14);
			self.ev.trigger('rsOnUpdateNav');
		},
		_setGrabCursor:function() {
			var self = this;
			if(self._hasDrag && self._isMove) {
				if(self._grabCursor) {
					self._sliderOverflow.css('cursor', self._grabCursor);
				} else {
					self._sliderOverflow.removeClass('grabbing-cursor');
					self._sliderOverflow.addClass('grab-cursor');
				}
			}
		},
		_setGrabbingCursor:function() {
			var self = this;
			if(self._hasDrag && self._isMove) {
				if(self._grabbingCursor) {
					self._sliderOverflow.css('cursor', self._grabbingCursor);
				} else {
					self._sliderOverflow.removeClass('grab-cursor');
					self._sliderOverflow.addClass('grabbing-cursor');
				}
			}
		},
		next: function(notUserAction) {
			var self = this;
			self._moveTo('next',  self.st.transitionSpeed, true, !notUserAction);
		},
		prev: function(notUserAction) {
			var self = this;
			self._moveTo('prev', self.st.transitionSpeed, true, !notUserAction);
		},
		_moveTo:function(type,  speed, inOutEasing, userAction, fromSwipe) {
			var self = this,
				newPos,
				difference,
				i,
				newItemId;


			self.ev.trigger('rsBeforeMove', [type, userAction]);
			if(type === 'next') {
				newItemId = self.currSlideId+1;
			} else if(type === 'prev') {
				newItemId = self.currSlideId-1;
			} else {
				newItemId = type = parseInt(type, 10);
			}

			if(!self._loop) {
				if(newItemId < 0) {
					self._doBackAndForthAnim('left', !userAction);
					return;
				} else if(newItemId >= self.numSlides ) {
					self._doBackAndForthAnim('right', !userAction);
					return;
				}
			}

			if(self._isAnimating) {
				self._stopAnimation(true);
				inOutEasing = false;
			}

			difference = newItemId - self.currSlideId;



			self._prevSlideId = self.currSlideId;
			var prevId = self.currSlideId;
			var id = self.currSlideId + difference;
			var realId = self._realId;
			var temp;
			var delayed;
			if(self._loop) {
				id = self._updateBlocksContent(false, id);
				realId += difference;
			} else {
				realId = id;
			}
			self._newSlideId = id;

			self._oldHolder = self.slidesJQ[self.currSlideId];


			self._realId = realId;
			self.currSlideId = self._newSlideId;

			self.currSlide = self.slides[self.currSlideId];
			self._currHolder = self.slidesJQ[self.currSlideId];


			var checkDist = self.st.slidesDiff;
			var next = Boolean(difference > 0);
			var absDiff = Math.abs(difference);
			var g1 = Math.floor( prevId / self._numPreloadImages);
			var g2 = Math.floor( ( prevId + (next ? checkDist : -checkDist  ) ) / self._numPreloadImages);
			var biggest = next ? Math.max(g1,g2) : Math.min(g1,g2);
			var biggestId = biggest * self._numPreloadImages +  ( next ? (self._numPreloadImages - 1) : 0 );
			if(biggestId > self.numSlides - 1) {
				biggestId = self.numSlides - 1;
			} else if(biggestId < 0) {
				biggestId = 0;
			}
			var toLast =  next ? (biggestId - prevId) :  (prevId - biggestId);
			if(toLast > self._numPreloadImages) {
				toLast = self._numPreloadImages;
			}
			if(absDiff > toLast + checkDist) {
				self._idOffset +=  ( absDiff - (toLast + checkDist) ) * ( next ? -1 : 1 );
				speed = speed * 1.4;
				for(i = 0; i < self.numSlides; i++) {
					self.slides[i].positionSet = false;
				}
			}
			self._currAnimSpeed = speed;

			self._updateBlocksContent(true);
			if(!fromSwipe) {
				delayed = true;
			}


			newPos = (-realId - self._idOffset) * self._slideSize;



			if(delayed) {
				setTimeout(function() {
					self._isWorking = false;
					self._animateTo(newPos, type, false, inOutEasing);
					self.ev.trigger('rsOnUpdateNav');
				}, 0);
			} else {
				self._animateTo(newPos, type, false, inOutEasing);
				self.ev.trigger('rsOnUpdateNav');
			}


			function isSetToCurrent(testId) {
				if(testId < 0) {
					testId = self.numSlides + testId;
				} else if(testId > self.numSlides - 1) {
					testId = testId - self.numSlides;
				}
				if(testId !== self.currSlideId) {
					return false;
				}
				return true;
			}

		},
		_updateArrowsNav: function() {
			var self = this,
				arrDisClass = 'rsArrowDisabled';
			if(self.st.arrowsNav) {
				if(self.numSlides <= 1) {
					self._arrowLeft.css('display', 'none');
					self._arrowRight.css('display', 'none');
					return;
				} else {
					self._arrowLeft.css('display', 'block');
					self._arrowRight.css('display', 'block');
				}
				if(!self._loop && !self.st.loopRewind) {
					if(self.currSlideId === 0) {
						self._arrowLeft.addClass(arrDisClass);
					} else {
						self._arrowLeft.removeClass(arrDisClass);
					}
					if(self.currSlideId === self.numSlides - 1) {
						self._arrowRight.addClass(arrDisClass);
					} else {
						self._arrowRight.removeClass(arrDisClass);
					}
				}
			}
		},
		_animateTo:function(pos, dir,  loadAll, inOutEasing, customComplete) {
			var self = this,
				moveProp,
				oldBlock,
				animBlock;

			var animObj = {};
			if(isNaN(self._currAnimSpeed)) {
				self._currAnimSpeed = 400;
			}



			self._sPosition = self._currRenderPosition = pos;

			self.ev.trigger('rsBeforeAnimStart');

			if(!self._useCSS3Transitions) {
				if(self._isMove) {
					animObj[self._slidesHorizontal ? self._xProp : self._yProp] = pos + 'px';


					self._slidesContainer.animate(animObj, self._currAnimSpeed, /*'easeOutQuart'*/ inOutEasing ? self.st.easeInOut : self.st.easeOut);
				} else {
					oldBlock = self._oldHolder;
					animBlock = self._currHolder;

					animBlock.stop(true, true).css({
						opacity: 0,
						display: 'block',
						zIndex: self._fadeZIndex
					});
					self._currAnimSpeed = self.st.transitionSpeed;
					animBlock.animate({opacity: 1}, self._currAnimSpeed, self.st.easeInOut);


					clearTimeouts();
					if(oldBlock) {
						oldBlock.data('rsTimeout', setTimeout(function() {
							oldBlock.stop(true, true).css({
								opacity: 0,
								display: 'none',
								zIndex: 0
							});
						}, self._currAnimSpeed + 60) );
					}
				}

			} else {
				if(self._isMove) {



						self._currAnimSpeed = parseInt(self._currAnimSpeed, 10);
						var td = self._vendorPref + self._TD;
						var ttf = self._vendorPref + self._TTF;

						animObj[td] = self._currAnimSpeed+'ms';
						animObj[ttf] = inOutEasing ? $.recipeBoxRsCSS3Easing[self.st.easeInOut] : $.recipeBoxRsCSS3Easing[self.st.easeOut];

						self._slidesContainer.css(animObj);
					if(inOutEasing || !self.hasTouch) {
						setTimeout(function() {
							self._setPosition(pos);
						}, 5);
					} else {
						self._setPosition(pos);
					}



				} else {
					//self._currAnimSpeed = 10
					self._currAnimSpeed = self.st.transitionSpeed;
					oldBlock = self._oldHolder;
					animBlock = self._currHolder;
					if(animBlock.data('rsTimeout')) {
						animBlock.css('opacity', 0);
					}
					clearTimeouts();
					if(oldBlock) {
						//if(oldBlock)
						oldBlock.data('rsTimeout', setTimeout(function() {
							animObj[self._vendorPref + self._TD] = '0ms';
							animObj.zIndex = 0;
							animObj.display = 'none';
							oldBlock.data('rsTimeout', '');
							oldBlock.css(animObj);
							setTimeout(function() {
								oldBlock.css('opacity', 0);
							}, 16);
						}, self._currAnimSpeed + 60) );
					}

					animObj.display = 'block';
					animObj.zIndex = self._fadeZIndex;
					animObj.opacity = 0;
					animObj[self._vendorPref + self._TD] = '0ms';
					animObj[self._vendorPref + self._TTF] = $.recipeBoxRsCSS3Easing[self.st.easeInOut];
					animBlock.css(animObj);
					animBlock.data('rsTimeout', setTimeout(function() {
						//animBlock.css('opacity', 0);
						animBlock.css(self._vendorPref + self._TD,  self._currAnimSpeed+'ms');

						//oldBlock.css(self._vendorPref + self._TD,  '0ms');
						animBlock.data('rsTimeout', setTimeout(function() {
							animBlock.css('opacity', 1);
							animBlock.data('rsTimeout', '');
						}, 20) );
					}, 20) );
				}
			}
			self._isAnimating = true;
			if(self.loadingTimeout) {
				clearTimeout(self.loadingTimeout);
			}
			if(customComplete) {
				self.loadingTimeout = setTimeout(function() {
					self.loadingTimeout = null;
					customComplete.call();

				}, self._currAnimSpeed + 60);
			} else {
				self.loadingTimeout = setTimeout(function() {
					self.loadingTimeout = null;
					self._animationComplete(dir);
				}, self._currAnimSpeed + 60);
			}

			function clearTimeouts() {
				var t;
				if(oldBlock) {
					t = oldBlock.data('rsTimeout');
					if(t) {
						if(oldBlock !== animBlock) {
							oldBlock.css({
									opacity: 0,
									display: 'none',
									zIndex: 0
								});
						}
						clearTimeout(t);
						oldBlock.data('rsTimeout', '');
					}
				}

				t = animBlock.data('rsTimeout');
				if(t) {
					clearTimeout(t);
					animBlock.data('rsTimeout', '');
				}
			}
		},
		_stopAnimation: function(noCSS3) {
			var self = this;
			self._isAnimating = false;
			clearTimeout(self.loadingTimeout);
			if(self._isMove) {

				if(!self._useCSS3Transitions) {
					self._slidesContainer.stop(true);
					self._sPosition = parseInt(self._slidesContainer.css(self._xProp), 10);
				} else if (!noCSS3) {
					var oldPos = self._sPosition;
					var newPos =  self._currRenderPosition = self._getTransformProp();
					self._slidesContainer.css((self._vendorPref + self._TD), '0ms');
					if(oldPos !==newPos) {
						self._setPosition(newPos);
					}
				}
			} else {
				// kung fu
				if(self._fadeZIndex > 20) {
					self._fadeZIndex = 10;
				} else {
					self._fadeZIndex++;
				}
			}


		},
		// Thanks to @benpbarnett
		_getTransformProp:function(){
			var self = this,
				transform = window.getComputedStyle(self._slidesContainer.get(0), null).getPropertyValue(self._vendorPref + 'transform'),
				explodedMatrix = transform.replace(/^matrix\(/i, '').split(/, |\)$/g),
				isMatrix3d = (explodedMatrix[0].indexOf('matrix3d') === 0);
			return parseInt(explodedMatrix[(self._slidesHorizontal ? (isMatrix3d ? 12 : 4) : (isMatrix3d ? 13 : 5) )], 10);
		},
		_getCSS3Prop: function(pos, hor) {
			var self = this;
			return self._useCSS3Transitions ? self._tPref1 + ( hor ? (pos + self._tPref2 + 0) : (0 + self._tPref2 + pos) ) + self._tPref3 : pos;
		},
		_animationComplete: function(dir) {
			var self = this;
			if(!self._isMove) {
				self._currHolder.css('z-index', 0);
				self._fadeZIndex = 10;
			}
			self._isAnimating = false;

			self.staticSlideId = self.currSlideId;
			self._updateBlocksContent();


			self._slidesMoved = false;

			self.ev.trigger('rsAfterSlideChange');
		},
		_doBackAndForthAnim:function(type, userAction) {
			var self = this,
				newPos = (-self._realId - self._idOffset) * self._slideSize;

			if(self.numSlides === 0 || self._isAnimating) {
				return;
			}
			if(self.st.loopRewind) {
				self.goTo(type === 'left' ? self.numSlides - 1 : 0, userAction);
				return;
			}

			if(self._isMove) {
				self._currAnimSpeed = 200;

				var allAnimComplete = function () {
					self._isAnimating = false;
				};
				var firstAnimComplete = function () {
					self._isAnimating = false;
					self._animateTo(newPos, '', false, true, allAnimComplete);
				};
				self._animateTo(newPos + (type === 'left' ? 30 : -30),'', false, true, firstAnimComplete);
			}

		},
		_resizeImage:function(slideObject, useClone) {

			var isRoot = true;
			if(slideObject.isRendered) {
				return;
			}
			var img = slideObject.content;
			var classToFind = 'rsMainSlideImage';
			var isVideo;
			var self = this,
				imgAlignCenter = self.st.imageAlignCenter,
				imgScaleMode = self.st.imageScaleMode,
				tempEl,
				bMargin;

			if(slideObject.videoURL) {
				classToFind = 'rsVideoContainer';
				if(imgScaleMode !== 'fill') {
					isVideo = true;
				} else {
					tempEl = img;
					if(!tempEl.hasClass(classToFind)) {
						tempEl = tempEl.find('.'+classToFind);
					}
					tempEl.css({width:'100%',height: '100%'});
					classToFind = 'rsMainSlideImage';
				}
			}
			if(!img.hasClass(classToFind)) {
				isRoot = false;
				img = img.find('.'+classToFind);
			}
			if(!img) {
				return;
			}

			var baseImageWidth = slideObject.iW,
				baseImageHeight = slideObject.iH;

			slideObject.isRendered = true;
			if(imgScaleMode === 'none' && !imgAlignCenter) {
				return;
			}
			if(imgScaleMode !== 'fill') {
				bMargin = self._imagePadding;
			} else {
				bMargin = 0;
			}
			//var block = img.parent('.block-inside').css('margin', bMargin);
			var containerWidth = self._wrapWidth - bMargin * 2,
				containerHeight = self._wrapHeight - bMargin * 2,
				hRatio,
				vRatio,
				ratio,
				nWidth,
				nHeight,
				cssObj = {};

			if(imgScaleMode === 'fit-if-smaller') {
				if(baseImageWidth > containerWidth || baseImageHeight > containerHeight) {
					imgScaleMode = 'fit';
				}
			}
			if(imgScaleMode === 'fill' || imgScaleMode === 'fit') {
				hRatio = containerWidth / baseImageWidth;
				vRatio = containerHeight / baseImageHeight;

				if (imgScaleMode  == "fill") {
					ratio = hRatio > vRatio ? hRatio : vRatio;
				} else if (imgScaleMode  == "fit") {
					ratio = hRatio < vRatio ? hRatio : vRatio;
				} else {
					ratio = 1;
				}

				nWidth = Math.ceil(baseImageWidth * ratio, 10);
				nHeight = Math.ceil(baseImageHeight * ratio, 10);
			} else {
				nWidth = baseImageWidth;
				nHeight = baseImageHeight;
			}
			if(imgScaleMode !== 'none') {
				cssObj.width = nWidth;
				cssObj.height = nHeight;
				if(isVideo) {
					img.find('.rsImg').css({width: '100%', height:'100%'});
				}
			}
			if (imgAlignCenter) {
				cssObj.marginLeft = Math.floor((containerWidth - nWidth) / 2) +  bMargin;
				cssObj.marginTop = Math.floor((containerHeight - nHeight) / 2) +  bMargin;
			}
			img.css(cssObj);
		}
	}; /* RoyalSlider core prototype end */
	$.recipeBoxRsProto = RoyalSlider.prototype;

	$.fn.recipeBoxRoyalSlider = function(options) {
		var args = arguments;
		return this.each(function(){
			var self = $(this);
			if (typeof options === "object" ||  !options) {
				if( !self.data('royalSlider') ) {
					self.data('royalSlider', new RoyalSlider(self, options));
				}
			} else {
				var royalSlider = self.data('royalSlider');
				if (royalSlider && royalSlider[options]) {
					return royalSlider[options].apply(royalSlider, Array.prototype.slice.call(args, 1));
				}
			}
		});
	};

	$.fn.recipeBoxRoyalSlider.defaults = {
		slidesSpacing: 8,
		startSlideId: 0,
		loop: false,
		loopRewind: false,
		numImagesToPreload: 4,
		fadeinLoadedSlide: true,
		slidesOrientation: 'horizontal',
		transitionType: 'move',
		transitionSpeed: 600,
		controlNavigation: 'bullets',
		controlsInside: true,
		arrowsNav: true,
		arrowsNavAutoHide: true,
		navigateByClick: true,
		randomizeSlides: false,
		sliderDrag: true,
		sliderTouch: true,
		keyboardNavEnabled: false,
		fadeInAfterLoaded: true,

		allowCSS3: true,
		allowCSS3OnWebkit: true,


		addActiveClass: false,
		autoHeight: false,

		easeOut: 'easeOutSine',
		easeInOut: 'easeInOutSine',

		minSlideOffset: 10,

		imageScaleMode:"fit-if-smaller",
		imageAlignCenter:true,
		imageScalePadding: 4,
		usePreloader: true,

		autoScaleSlider: false,

		autoScaleSliderWidth: 800,
		autoScaleSliderHeight: 400,

		autoScaleHeight: true,

		arrowsNavHideOnTouch: false,
		globalCaption: false,

		slidesDiff: 2
	}; /* default options end */

	$.recipeBoxRsCSS3Easing = {
		easeOutSine: 'cubic-bezier(0.390, 0.575, 0.565, 1.000)',
		easeInOutSine: 'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
	};

	$.extend(jQuery.easing, {
		easeInOutSine: function (x, t, b, c, d) {
			return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
		},
		easeOutSine: function (x, t, b, c, d) {
			return c * Math.sin(t/d * (Math.PI/2)) + b;
		},
		easeOutCubic: function (x, t, b, c, d) {
			return c*((t=t/d-1)*t*t + 1) + b;
		}
	});

        /**
         *
         * RoyalSlider bullets module
         * @version 1.0.1:
         *
         * 1.0.1
         * - Minor optimizations
         *
         */
        $.extend($.recipeBoxRsProto, {
            _initBullets: function() {
                var self = this;
                if(self.st.controlNavigation === 'bullets') {
                    var itemHTML = '<div class="rsNavItem rsBullet"><span></span></div>';
                    self.ev.one('rsAfterPropsSetup', function() {

                        self._controlNavEnabled = true;
                        self.slider.addClass('rsWithBullets');
                        var out = '<div class="rsNav rsBullets">';
                        for(var i = 0; i < self.numSlides; i++) {
                            out += itemHTML;
                        }
                        self._controlNav = out = $(out + '</div>');
                        self._controlNavItems = out.appendTo(self.slider).children();

                        self._controlNav.on('click.rs','.rsNavItem',function(e) {
                            if(!self._thumbsDrag ) {
                                self.goTo( $(this).index() );
                            }
                        });
                    });

                    self.ev.on('rsOnAppendSlide', function(e, parsedSlide, index) {
                        if(index >= self.numSlides) {
                            self._controlNav.append(itemHTML);
                        } else {
                            self._controlNavItems.eq(index).before(itemHTML);
                        }
                        self._controlNavItems = self._controlNav.children();
                    });
                    self.ev.on('rsOnRemoveSlide', function(e, index) {
                        var itemToRemove = self._controlNavItems.eq(index);
                        if(itemToRemove && itemToRemove.length) {
                            itemToRemove.remove();
                            self._controlNavItems = self._controlNav.children();
                        }

                    });

                    self.ev.on('rsOnUpdateNav', function() {
                        var id = self.currSlideId,
                            currItem,
                            prevItem;
                        if(self._prevNavItem) {
                            self._prevNavItem.removeClass('rsNavSelected');
                        }
                        currItem = self._controlNavItems.eq(id);

                        currItem.addClass('rsNavSelected');
                        self._prevNavItem = currItem;
                    });
                }
            }
        });
        $.recipeBoxRsModules.bullets = $.recipeBoxRsProto._initBullets;
});
/*
 * jQuery truncate plugin, version 3.0 [2015-02-04]
 * Copyright 2015, Perfect Sense Digital LLC
 * Author: Brendan Brelsford [brendanb@gmail.com]
 * Licensed under the MIT license [http://opensource.org/licenses/MIT]
 *
 * Usage:
 *
 *     Invocation
 *
 *     $('.selector').truncate(options);
 *
 *     Event Binding (after invocation)
 *
 *     $('.selector').truncate('bind', 'show', function(){ // do something when full text is shown});
 *
 * Events:
 *
 *     Events are triggered on the following state changes of the selected element.  No events are triggered
 *     on the initial invocation of the truncate plugin.
 *
 *     "show" - Triggered when full text is shown.  If options.animate is specified to be true, then this event will fire
 *                  after the animation has completed.
 *
 *     "hide" - Triggered when full text is truncated.  If options.animate is specified to be true, then this event will fire
 *                  after the animation has completed.
 *
 *     "toggle" - Triggered both when full text is shown and truncated.  If options.animate is specified to be true, then this
 *                  event will fire after the animation has completed.
 *
 * Options:
 *
 *     Options are passed as a flat javascript object with the following allowed keys:
 *
 *     "maxLines" - The maximum number of lines to display when the element is truncated.
 *                  Allowed Values: integer > 0
 *                  Default Value: 1
 *
 *     "lineHeight" - The line-height value that should be used to calculate the vertical truncation point.  If unspecified,
 *                  it will be calculated using the CSS value from each selected element.
 *                  Allowed Values: integer > 0
 *                  Default Value: null
 *
 *     "truncateString" - Suffix to append to truncated text. e.g. &nbsp;&#8230; (non-breaking space followed by an ellipsis).
 *                  Allowed Values: any string
 *                  Default Value: ''
 *
 *     "truncateAfterLinks" - Indicates whether options.truncateString should be appended after anchor tags when the truncation
 *                  point occurs inside an anchor tag.  Since the truncateString is not part of the original anchor text, it is
 *                  desirable to exclude it from the anchor tag.  In cases where anchor tags display as block, however, this can
 *                  cause the truncateString to display on a line below the anchor tag.
 *                  Allowed Values: true / false
 *                  Default Value: true
 *
 *     "showText" - If specified, will be shown as a hyperlink appended to the truncated text.  When clicked, this link
 *                  will toggle the truncated element to its full-text state. e.g. ("more")
 *                  Allowed Values: any string
 *                  Default Value: ''
 *
 *     "hideText" - If specified, will be shown as a hyperlink appended to the full text.  When clicked, this link will
 *                  toggle the full-text element to its truncated state.  e.g. ("less")
 *                  Allowed Values: any string
 *                  Default Value: ''
 *
 *     "showClass" - CSS class to be used when generating and selecting the clickable link to show the full text.
 *                  Allowed Values: any string
 *                  Default Value: 'show'
 *
 *     "hideClass" - CSS class to be used when generating and selecting the clickable link to hide the full text.
 *                  Allowed Values: any string
 *                  Default Value: 'hide'
 *
 *     "collapsed" - Indicates whether the truncated element should be initially displayed in a full-text or truncated state.
 *                  Allowed Values: true / false
 *                  Default Value: true
 *
 *     "debug" - Indicates whether messages should be written to console.log including the truncation execution time and
 *                  number of binomal search steps used to truncate the full text.  The usage of console.log in this plugin
 *                  is always safe for inclusion in IE.
 *                  Allowed Values: true / false
 *                  Default Value: false
 *
 *     "contextParent" - A parent DOM element to use as the cloned element for measuring height of the cloned text.  This is necessary
 *                  when the text node can have its text displaced by floated elements inside a common parent.
 *                  Allowed Values: jQuery object
 *                  Default Value: null
 *
 *     "tooltip" - Indicates whether the original TEXT content should be set in a title attribute on the truncated element.  This will
 *                  strip all HTML for compatibility with HTML attribute syntax.
 *                  Allowed Values: true / false
 *                  Default Value: false
 *
 *     "animate" - Indicates whether the user-initiated transitions between truncated and full text should animate the height.  
 *                  Allowed Values: true / false
 *                  Default Value: false
 *
 *     "animateOptions" - If specified, will be passed into jQuery's $.fn.animate options parameter.
 *                  Allowed Values: object
 *                  Default Value: empty object
 *
 * Methods:
 *
 *      Methods are invoked via $('.selector').truncate(methodName, arguments...)
 *
 *      "options" - Pass an object argument to reset the options.  This does not immediately trigger an updated truncation.
 *
 *      "update" - Takes an optional second argument to pass new HTML.  With or without the argument, the original truncated
 *                 element will be re-truncated.  This is useful to hook into a callback when the truncated element can be
 *                 subject to re-sizing (i.e. responsive design).  If no HTML is passed, but the contents of the truncated text
 *                 have been modified, the modified text will be used in place of the original.
 *
 * Examples:
 *
 *     Truncate to 3 lines with a trailing ellipsis, "Read More" text when collapsed, and no hide text.
 *
 *     $('.selector').truncate({
 *         'maxLines': 3,
 *         'truncateString': '&nbsp;&#8230;',
 *         'showText': 'Read More'
 *     });
 *
 *     Truncate to 3 lines with a trailing ellipsis, relative to a context parent that includes a floated image.
 *
 *     var $el = $('.selector');
 *     var $contextParent = $el.closest('.parent-selector');
 *
 *     $('.selector').truncate({
 *         'maxLines': 3,
 *         'truncateString': '&nbsp;&#8230;',
 *         'contextParent': $contextParent
 *     });
 *
 * Known Issues:
 *
 *     - Truncating HTML without consideration for the timing of web font loading will produce incorrectly truncated text.
 *         In cases where web fonts are used, either delay truncation until after the web fonts are loaded or call the
 *         "update" method after the web fonts have loaded.  A good plugin for detecting when a web font has been loaded is:
 *
 *         https://github.com/patrickmarabeas/jQuery-FontSpy.js
 *
 *         Which is based on Remy Sharp's usage of Comic Sans for determining whether a named font is loaded:
 *
 *         https://remysharp.com/2008/07/08/how-to-detect-if-a-font-is-installed-only-using-javascript
 *
 *     - The "update" method with 0 parameters will fail to recognize a change in the truncated HTML if the HTML length is
 *         the same as before the change was made.
 */

window.boxContextLoaded(function(jQuery) {

    var cumulativeExecutionTime = 0;
   var $ = jQuery;

        // matching expression to determine the last word in a string.
        var lastWordPattern = /(?:^|\W*)\w*$/;
        // first word MUST be suffixed by non-alpha, since usage of this regexp occurs in a spliced segment of the original string
        var firstWordPattern = /(?:\w+)(?=\W+|$)/;

        // define "setNodeText" differently for Internet Explorer
        var setNodeText = /msie/i.exec(navigator.userAgent) !== null ? function(node, text) {
            node.nodeValue = text;
        } : function(node, text) {
            node.textContent = text;
        };
		
		var browserFloorsLineHeight = false;
		var browserRoundsBoxHeight = false;
		
		var calculateHeight = function(maxLines, lineHeight) {
			
			var rawHeight = maxLines * (browserFloorsLineHeight === true ? Math.floor(lineHeight) : lineHeight);
			
			return browserRoundsBoxHeight === true ? Math.round(rawHeight) : rawHeight;
		};
		
		var calculateMaxHeight = function(maxLines, lineHeight) {
			
			var rawHeight = (maxLines + 1) * (browserFloorsLineHeight === true ? Math.floor(lineHeight) : lineHeight) - 1;
			
			return browserRoundsBoxHeight === true ? Math.round(rawHeight) : rawHeight;
		};
		
		var setCustomBrowserBehavior = function() {
			
			var LINE_ROUND_UP_HEIGHT = 1.43125;
			
			var $detector = $('<div />', {
				'id': 'truncate-detect-height-method',
				'text': '. . . .' // two lines of text
			});
			
			$detector.css({
				'line-height': LINE_ROUND_UP_HEIGHT,
				'font-size': '16px',
				'font-family': 'sans-serif',
				'width': 0,
				'position': 'absolute',
				'top': 0,
				'left': 0,
				'visibility': 'hidden'
			});
			
			$('body').append($detector);
			
			var calculatedLineHeight = parseFloat($detector.css('line-height'));
			
			var delta = Math.abs(calculatedLineHeight * 4 - $detector.height());
			
			if(delta === 0) {
				return;
			}
			
			if(delta < 1) {
				browserRoundsBoxHeight = true;
			} else if(delta > 1) {
				browserFloorsLineHeight = true;
			}
			
			setCustomBrowserBehavior = function() { };
		};

        // defines a utility function to splice HTML at a text offset
        var getHtmlUntilTextOffset = function(html, offset, truncateString, truncateAfterLinks) {

            var queue = [];
            var $html = $('<div/>');
            $html.html(html);
            var textLen = 0;

            // testing var to prevent infinite loops
            var count = 0;

            // remove child nodes from this node and push all onto the queue in reverse order (this implements depth-first search).
            var rootChildren = $html.contents().detach();
            var n = 0;
            for(n = rootChildren.size() - 1; n >= 0; n -= 1) {

                queue.push({$parent: $html, node: rootChildren.get(n)});
            }
			
			var queueItem, node, $node, nodeTextLen, nodeText, $nodeParent, match, lastWordOffset, children, i;

            while((queue.length > 0) && (textLen < offset) && (count < 100)) {

                queueItem = queue.pop();
                node = queueItem.node;
                $node = $(node);
                nodeTextLen = 0;

                // process text nodes distinctly from other node types
                if(node.nodeType === 3) {

                    $nodeParent = queueItem.$parent;

                    // append $node to $html with children.  if children were detached above, then this is an empty node
                    $nodeParent.append($node);

                    nodeText = $node.text();
                    nodeTextLen = nodeText.length;

                    // if the text node's contents would put textLen above offset, perform truncation
                    if (nodeTextLen > offset - textLen) {

                        match = lastWordPattern.exec(nodeText.substring(0, offset - textLen));
                        lastWordOffset = match.index + match[0].length;
                        setNodeText(node, nodeText.substring(0, lastWordOffset));

                        if(truncateString !== undefined) {
                            if(!($nodeParent.is('a')) || truncateAfterLinks === false) {
                                $nodeParent.append(truncateString);
                            } else {
                                $nodeParent.parent().append(truncateString);
                            }
                        }

                        // stop processing nodes.  the last word that will not exceed the offset has been found.
                        textLen += lastWordOffset;
                        break;

                    }
					
                    textLen += nodeTextLen;

                } else {

                    nodeText = $node.text();
                    nodeTextLen = nodeText.length;

                    // if the text content of this node and its children is greater than the gap between the accumulated text length and offset
                    if(nodeTextLen > offset - textLen) {

                        // remove child nodes from this node and push all onto the queue in reverse order (this implements depth-first search).
                        children = $node.contents().detach();
                        i = 0;
                        for(i = children.size() - 1; i >= 0; i -= 1) {

                            queue.push({$parent: $node, node: children.get(i)});
                        }
                    } else {

                        textLen += nodeTextLen;
                    }

                    // append $node to $html with children.  if children were detached above, then this is an empty node
                    queueItem.$parent.append($node);
                }

                if(textLen === offset) {
                    queueItem.$parent.append(truncateString);
                }
            }

            return $html.html();
        };

        var closestBlockLevelAncestor = function($el) {
            var $parent = $el.parent();
            while($parent !== undefined && $parent.size() > 0) {
                if('inline' !== $parent.css('display')) {
                    return $parent;
                }
                $parent = $parent.parent();
            }
            return null;
        };

        // define main workhorse method, "truncate" to be used both on the initial call and on subsequent invocations of the "update" method
        var truncate = function($el, options, html) {

            // declare variable to store response value - the char offset at which truncation occurred
            var truncationPoint = null;

            // define DEBUG function specific to each instance
            var DEBUG = function() {

                var isDebug = window.location.hash.indexOf("_debugTruncate") !== -1;
                if((isDebug || options.debug === true) && window.console !== undefined) {
                    if(/msie/i.exec(navigator.userAgent) !== null) {
                        var output = "";
                        var i;
                        for(i = 0; i < arguments.length; i+= 1) {
                            if(output.length > 0) {
                                output += ", ";
                            }
                            if(typeof arguments[i] === 'function') {
                                output += "[function]";
                            } else if(typeof arguments[i] === 'object' && typeof JSON === 'object' && typeof JSON.stringify === 'function') {
                                output += JSON.stringify(arguments[i]);
                            } else {
                                output += arguments[i].toString();
                            }
                        }
                        console.log(output);
                    } else {
                        try {
                            console.log.apply(null, arguments);
                        } catch(e) {
                            console.log(arguments);
                        }
                    }
                }
            };
			
			setCustomBrowserBehavior();

            // options-based variables
            var showLinkHtml = options.showText !== '' ? ' <a class="' + options.showClass + '" href="#">' + options.showText + '</a>' : '';
            var hideLinkHtml = options.hideText !== '' ? ' <a class="' + options.hideClass + '" href="#">' + options.hideText + '</a>' : '';
            var maxHeight = calculateHeight(options.maxLines, options.lineHeight);
            var realMaxHeight = calculateMaxHeight(options.maxLines, options.lineHeight);

            // used to debug the execution time
            var startTime = new Date();

            // this variable is used to hold the un-truncated HTML, since $el may already contain truncated HTML
            var $html = $('<div/>');
            $html.html(html);

            // proceed if the element has already been truncated, or if its height is larger than the real max height
            if ($el.data('truncatePlugin') !== undefined || $el.height() > realMaxHeight) {

                // check whether a $parent element was specified for a larger DOM context
                var $contextParent = (options.contextParent === null || options.contextParent === $el) ? $el : $(options.contextParent);

                // clone of the selected element
                var $doppleText;
                // clone of the options.contextParent, for use when contextParent is specified
                var $doppleParent;

                // If the contextParent contains the selected element, then they are ancestor-descendent.
                // If not, then set the contextParent to the element itself.
                if($contextParent.find($el).size() > 0) {

                    // If a contextParent was specified, then the cloned element itself must be found
                    // by navigating the original HTML structure and mirroring the navigation in the
                    // cloned HTML structure.
                    var childOffsets = [];
                    var $node = $el;
                    var $closestParent = $node.parent();
                    while($closestParent.size() !== 0 && !($closestParent.find($contextParent).size() > 0)) {

                        childOffsets.unshift($node.index());
                        $node = $closestParent;
                        $closestParent = $closestParent.parent();
                    }

                    // The array of childOffsets stores the offset of the cloned element's ancestor at each
                    // level of the DOM heirarchy, relative to the cloned parent.  By iteratively navigating
                    // to the specified child index, the cloned element can be found.
                    $doppleParent = $contextParent.clone();
                    $doppleText = $doppleParent;
                    var i, offset;
                    for(i = 0; i < childOffsets.length; i += 1) {
                        offset = childOffsets[i];
                        $doppleText = $doppleText.children().eq(offset);
                    }

                    // Always reset the html of the clone, because this function is used both for initial and repeat
                    // truncations.  In the latter case, $el.html() is already truncated, so the clone must use the original
                    // html, passed as a parameter to this method.
                    $doppleText.html(html);
                } else {

                    $doppleText = $el.clone();
                    // Always reset the html of the clone (see directly above)
                    $doppleText.html(html);
                    $doppleParent = $doppleText;
                }

                var width;
                if($contextParent.css('-moz-box-sizing') === 'border-box'
                    || $contextParent.css('-webkit-box-sizing') === 'border-box'
                    || $contextParent.css('box-sizing') === 'border-box') {
                    width = $contextParent.outerWidth();
                } else {
                    width = $contextParent.width();
                }

                // Position the clone outside the page but still visibile, so that the browser can accurately detect
                // its height during the binary search.
                $doppleParent.css({
                    'position': 'absolute',
                    'left': '0',
                    'top': '0',
                    'visibility': 'hidden',
                    'max-width': width // set max-width instead of width, because setting width directly can result in small display deviations
                });
                // Enforce the 'line-height' style to ensure that the calculation is correct.
                $doppleText.css({
                    'line-height': options.lineHeight + 'px',
                    'height': 'auto'
                });

                $contextParent.after($doppleParent);

                // Determine the un-truncated HTML height by measuring the cloned element.  This will work both for initial and
                // repeat calls to "truncate".
                var originalHeight = $doppleText.height();

                // This second check is for elements that have already been truncated before, because the true "originalHeight"
                // can only be determined in these cases after the $doppleText has been appended to the DOM
                if(originalHeight > realMaxHeight) {

                    var textString = $html.text();
                    var near = 0;
                    var far = textString.length;
                    var mid = far;
                    var truncatedHtml;

                    var count = 0;
					var avg, nextWord, nextWordAt;

                    // Iterate either until the binary search has ended or options.maxSteps has been reached
                    // Three markers are used to implement the binary search: near, mid, and far.
                    do {
                        if($doppleText.height() > realMaxHeight) {
                            // If the text is too long, bring in the "far" marker
                            far = mid;
                        } else {
                            // If the text is too short, push out the "near" marker
                            near = mid;
                        }

                        // re-calculate the new mid to be the closest word boundary before the numerical midpoint of near & far
                        avg = Math.floor((far + near) / 2);
                        mid = lastWordPattern.exec(textString.substring(0, avg)).index;

                        // if this puts mid equal to near, try the first word pattern after the numerical midpoint of near & far
                        if(mid === near) {
                            nextWord = firstWordPattern.exec(textString.substring(avg, far));
                            if(nextWord !== null) {
                                nextWordAt = avg + nextWord.index + nextWord[0].length;
                                if(nextWordAt !== far) {
                                    mid = nextWordAt;
                                }
                            }
                        }

                        // Re-truncate the original HTML up to "mid" and put it into the cloned element
                        truncatedHtml = getHtmlUntilTextOffset(html, mid, options.truncateString, options.truncateAfterLinks);
                        $doppleText.html(truncatedHtml + showLinkHtml);
                        count += 1;
                    } while((count < options.maxSteps) && (mid > near) && (mid < far));

                    // truncatedHtml is already stored, so remove the cloned element
                    $doppleParent.remove();

                    // Append the either html + hideLinkHtml or truncatedHTML + showLinkHtml based on options.collapsed
                    if(options.collapsed === false) {
                        $el.html(html + hideLinkHtml);
                    } else {
                        $el.html(truncatedHtml + showLinkHtml);
                    }

                    // Enforce block display and the specified line-height on the truncated element
                    $el.css({
                        'display': 'block',
                        'line-height': options.lineHeight + 'px'
                    });

                    $el.undelegate('truncate');
                    // Delegate handlers to ".show" and ".hide" that swap the original / truncated HTML on click
                    $el.delegate('.' + options.showClass, 'click.truncate', function(event) {

                        event.preventDefault();

                        // fix the height before swapping in full content

                        $el.css({'height': maxHeight + 'px'});
                        $el.html(html + hideLinkHtml);
                        var $animateDfd = new $.Deferred();
                        $animateDfd.then(function() {

                            $el.css({'height': 'auto'});
                            $el.trigger('show');
                            $el.trigger('toggle');
                            if(options.tooltip === true) {
                                $el.removeAttr('title');
                            }
                        });

                        if(options.animate === true) {
                            var oldAnimateComplete = options.animateOptions.complete;
                            var animateOptions = $.extend(true, { }, options.animateOptions, {
                                'complete': function() {
                                    $animateDfd.resolve();
                                    oldAnimateComplete.apply(this, Array.prototype.slice.call(arguments, 1));
                                }
                            });
                            $el.animate({
                                'height': originalHeight + 'px'
                            }, animateOptions);
                        } else {
                            $animateDfd.resolve();
                        }
                    });

                    $el.delegate('.' + options.hideClass, 'click.truncate', function(event) {

                        event.preventDefault();

                        var $animateDfd = new $.Deferred();
                        $animateDfd.then(function() {
                            $el.html(truncatedHtml + showLinkHtml);
                            $el.trigger('hide');
                            $el.trigger('toggle');
                            if(options.tooltip === true) {
                                $el.attr('title', textString);
                            }
                        });

                        if(options.animate === true) {
                            var oldAnimateComplete = options.animateOptions.complete;
                            var animateOptions = $.extend(true, { }, options.animateOptions, {
                                'complete': function() {
                                    $animateDfd.resolve();
                                    oldAnimateComplete.apply(this, Array.prototype.slice.call(arguments, 1));
                                }
                            });
                            $el.animate({
                                'height': maxHeight + 'px'
                            }, animateOptions);
                        } else {
                            $animateDfd.resolve();
                        }
                    });

                    if(options.tooltip === true) {
                        $el.attr('title', textString);
                    }
                    DEBUG("truncate.js: truncated element with height " + originalHeight + "px > " + realMaxHeight + "px in " + count + " steps.");
                    truncationPoint = mid;

                } else {
                    $doppleParent.remove();
                    $el.html(html);
                    if(options.tooltip === true) {
                        $el.removeAttr('title');
                    }
                    truncationPoint = html.length;
                }
            } else {
                DEBUG("truncate.js: skipped processing element with height " + $el.height() + "px < " + realMaxHeight + "px");
                truncationPoint = html.length;
            }

            var endTime = new Date();

            cumulativeExecutionTime += (endTime - startTime);
            DEBUG("truncate.js: took " + (endTime - startTime) + "  ms to execute.");
            DEBUG("truncate.js: ", $el);
            DEBUG("truncate.js: cumulative execution time " + cumulativeExecutionTime + " ms");
            return truncationPoint;
        };

        function Truncate(el, options) {

            // --- Defaults ---
            this.defaults = {
                'maxLines': 1,
                'lineHeight': null,
                'truncateString': '',
                'truncateAfterLinks': true,
                'showText': '',
                'hideText': '',
				'showClass': 'show',
				'hideClass': 'hide',
                'collapsed': true,
                'debug': false,
                'contextParent': null,
                'maxSteps': 100,
                'tooltip': false,
                'animate': false,
                'animateOptions': {
                    'complete': function() { }
                }
            };

            // extend the default config with specified options
            this.config = $.extend(true, { }, this.defaults, options);

            // store a reference to the jQuery object
            this.$el = $(el);

            if(this.config.lineHeight === null) {
                var empiricalLineHeight = NaN;
                if("normal" === this.$el.css('line-height')) {

                    // Translate "normal" to a numeric pixel line-height: http://stackoverflow.com/questions/3614323/jquery-css-line-height-of-normal-px
                    empiricalLineHeight = 1.14 * parseFloat(this.$el.css('font-size'));
                }
                else if (this.$el.css('line-height').indexOf('px') === -1) {
                    empiricalLineHeight = this.$el.css('line-height') * parseFloat(this.$el.css('font-size'));
                } else {
                    empiricalLineHeight = parseFloat(this.$el.css('line-height'));
                }

                if(!isNaN(empiricalLineHeight)) {
                    this.config.lineHeight = empiricalLineHeight;
                } else {
                    throw new Error("No \"lineHeight\" parameter was specified and none could be calculated.");
                }
            }

            if('inline' === this.$el.css('display')) {
                if(this.config.contextParent === null) {
                    this.config.contextParent = closestBlockLevelAncestor(this.$el);
                } else if('inline' === this.config.contextParent.css('display')) {
                    this.config.contextParent = closestBlockLevelAncestor(this.config.contextParent);
                }
            }

            this.html = this.$el.html();
            this.lastTruncationPoint = null;
        }

        Truncate.prototype = {

            options: function(options) {
                if(typeof options === 'object') {
                    this.config = $.extend(true, { }, this.config, options);
                    return;
                }
                return this.config;
            },

            update: function(updatedHtml) {

                if(updatedHtml === undefined) {
                    var elementHtml = this.$el.html();
                    if(this.lastHtmlLength !== undefined && elementHtml.length !== this.lastHtmlLength) {
                        updatedHtml = elementHtml.substring(0,this.lastTruncationPoint) + this.html.substring(this.lastTruncationPoint);
                        this.html = updatedHtml;
                    }
                } else {
                    this.html = updatedHtml;
                }
                this.lastTruncationPoint = truncate(this.$el, this.config, this.html);
                this.lastHtmlLength = this.$el.html().length;
            },

            'getOriginalHtml': function() {
                return this.html;
            }
        };

        $.fn.truncate = function(methodName) {

            var $el = $(this);

            if(methodName === undefined || methodName === null || typeof methodName === 'object') {

                $el.each(function() {
                    var $this = $(this);
                    var plugin = new Truncate($this, methodName);
                    $this.data('truncatePlugin', plugin);
                    plugin.lastTruncationPoint = truncate($this, plugin.config, plugin.html);
                    plugin.lastHtmlLength = $this.html().length;
                });
            }

            var result;
            var methodArgs = arguments;

            if(typeof methodName === 'string') {
                $el.each(function() {
                    var plugin = $(this).data('truncatePlugin');
                    if(typeof plugin[methodName] === 'function') {
                        var newResult = plugin[methodName].apply(plugin, Array.prototype.slice.call(methodArgs, 1));
                        if(result === undefined) {
                            result = newResult;
                        }
                    }
                });
            }

            return typeof result !== 'undefined' ? result : this;
       };
});
/*!
 * jQuery.ScrollTo
 * Copyright (c) 2007-2013 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com
 * Dual licensed under MIT and GPL.
 *
 * @projectDescription Easy element scrolling using jQuery.
 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
 * @author Ariel Flesler
 * @version 1.4.6



 	UPDATED FOR BOX, WITH:   window.boxContextLoaded



 *
 * @id jQuery.scrollTo
 * @id jQuery.fn.scrollTo
 * @param {String, Number, DOMElement, jQuery, Object} target Where to scroll the matched elements.
 *	  The different options for target are:
 *		- A number position (will be applied to all axes).
 *		- A string position ('44', '100px', '+=90', etc ) will be applied to all axes
 *		- A jQuery/DOM element ( logically, child of the element to scroll )
 *		- A string selector, that will be relative to the element to scroll ( 'li:eq(2)', etc )
 *		- A hash { top:x, left:y }, x and y can be any kind of number/string like above.
 *		- A percentage of the container's dimension/s, for example: 50% to go to the middle.
 *		- The string 'max' for go-to-end. 
 * @param {Number, Function} duration The OVERALL length of the animation, this argument can be the settings object instead.
 * @param {Object,Function} settings Optional set of settings or the onAfter callback.
 *	 @option {String} axis Which axis must be scrolled, use 'x', 'y', 'xy' or 'yx'.
 *	 @option {Number, Function} duration The OVERALL length of the animation.
 *	 @option {String} easing The easing method for the animation.
 *	 @option {Boolean} margin If true, the margin of the target element will be deducted from the final position.
 *	 @option {Object, Number} offset Add/deduct from the end position. One number for both axes or { top:x, left:y }.
 *	 @option {Object, Number} over Add/deduct the height/width multiplied by 'over', can be { top:x, left:y } when using both axes.
 *	 @option {Boolean} queue If true, and both axis are given, the 2nd axis will only be animated after the first one ends.
 *	 @option {Function} onAfter Function to be called after the scrolling ends. 
 *	 @option {Function} onAfterFirst If queuing is activated, this function will be called after the first scrolling ends.
 * @return {jQuery} Returns the same jQuery object, for chaining.
 *
 * @desc Scroll to a fixed position
 * @example $('div').scrollTo( 340 );
 *
 * @desc Scroll relatively to the actual position
 * @example $('div').scrollTo( '+=340px', { axis:'y' } );
 *
 * @desc Scroll using a selector (relative to the scrolled element)
 * @example $('div').scrollTo( 'p.paragraph:eq(2)', 500, { easing:'swing', queue:true, axis:'xy' } );
 *
 * @desc Scroll to a DOM element (same for jQuery object)
 * @example var second_child = document.getElementById('container').firstChild.nextSibling;
 *			$('#container').scrollTo( second_child, { duration:500, axis:'x', onAfter:function(){
 *				alert('scrolled!!');																   
 *			}});
 *
 * @desc Scroll on both axes, to different values
 * @example $('div').scrollTo( { top: 300, left:'+=200' }, { axis:'xy', offset:-20 } );
 */

window.boxContextLoaded(function(jQuery) {
    var $ = jQuery;

	var $scrollTo = $.scrollTo = function( target, duration, settings ){
		$(window).scrollTo( target, duration, settings );
	};

	$scrollTo.defaults = {
		axis:'xy',
		duration: parseFloat($.fn.jquery) >= 1.3 ? 0 : 1,
		limit:true
	};

	// Returns the element that needs to be animated to scroll the window.
	// Kept for backwards compatibility (specially for localScroll & serialScroll)
	$scrollTo.window = function( scope ){
		return $(window)._scrollable();
	};

	// Hack, hack, hack :)
	// Returns the real elements to scroll (supports window/iframes, documents and regular nodes)
	$.fn._scrollable = function(){
		return this.map(function(){
			var elem = this,
				isWin = !elem.nodeName || $.inArray( elem.nodeName.toLowerCase(), ['iframe','#document','html','body'] ) != -1;

				if( !isWin )
					return elem;

			var doc = (elem.contentWindow || elem).document || elem.ownerDocument || elem;
			
			return /webkit/i.test(navigator.userAgent) || doc.compatMode == 'BackCompat' ?
				doc.body : 
				doc.documentElement;
		});
	};

	$.fn.scrollTo = function( target, duration, settings ){
		if( typeof duration == 'object' ){
			settings = duration;
			duration = 0;
		}
		if( typeof settings == 'function' )
			settings = { onAfter:settings };
			
		if( target == 'max' )
			target = 9e9;
			
		settings = $.extend( {}, $scrollTo.defaults, settings );
		// Speed is still recognized for backwards compatibility
		duration = duration || settings.duration;
		// Make sure the settings are given right
		settings.queue = settings.queue && settings.axis.length > 1;
		
		if( settings.queue )
			// Let's keep the overall duration
			duration /= 2;
		settings.offset = both( settings.offset );
		settings.over = both( settings.over );

		return this._scrollable().each(function(){
			// Null target yields nothing, just like jQuery does
			if (target == null) return;

			var elem = this,
				$elem = $(elem),
				targ = target, toff, attr = {},
				win = $elem.is('html,body');

			switch( typeof targ ){
				// A number will pass the regex
				case 'number':
				case 'string':
					if( /^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ) ){
						targ = both( targ );
						// We are done
						break;
					}
					// Relative selector, no break!
					targ = $(targ,this);
					if (!targ.length) return;
				case 'object':
					// DOMElement / jQuery
					if( targ.is || targ.style )
						// Get the real position of the target 
						toff = (targ = $(targ)).offset();
			}
			$.each( settings.axis.split(''), function( i, axis ){
				var Pos	= axis == 'x' ? 'Left' : 'Top',
					pos = Pos.toLowerCase(),
					key = 'scroll' + Pos,
					old = elem[key],
					max = $scrollTo.max(elem, axis);

				if( toff ){// jQuery / DOMElement
					attr[key] = toff[pos] + ( win ? 0 : old - $elem.offset()[pos] );

					// If it's a dom element, reduce the margin
					if( settings.margin ){
						attr[key] -= parseInt(targ.css('margin'+Pos)) || 0;
						attr[key] -= parseInt(targ.css('border'+Pos+'Width')) || 0;
					}
					
					attr[key] += settings.offset[pos] || 0;
					
					if( settings.over[pos] )
						// Scroll to a fraction of its width/height
						attr[key] += targ[axis=='x'?'width':'height']() * settings.over[pos];
				}else{ 
					var val = targ[pos];
					// Handle percentage values
					attr[key] = val.slice && val.slice(-1) == '%' ? 
						parseFloat(val) / 100 * max
						: val;
				}

				// Number or 'number'
				if( settings.limit && /^\d+$/.test(attr[key]) )
					// Check the limits
					attr[key] = attr[key] <= 0 ? 0 : Math.min( attr[key], max );

				// Queueing axes
				if( !i && settings.queue ){
					// Don't waste time animating, if there's no need.
					if( old != attr[key] )
						// Intermediate animation
						animate( settings.onAfterFirst );
					// Don't animate this axis again in the next iteration.
					delete attr[key];
				}
			});

			animate( settings.onAfter );			

			function animate( callback ){
				$elem.animate( attr, duration, settings.easing, callback && function(){
					callback.call(this, targ, settings);
				});
			};

		}).end();
	};
	
	// Max scrolling position, works on quirks mode
	// It only fails (not too badly) on IE, quirks mode.
	$scrollTo.max = function( elem, axis ){
		var Dim = axis == 'x' ? 'Width' : 'Height',
			scroll = 'scroll'+Dim;
		
		if( !$(elem).is('html,body') )
			return elem[scroll] - $(elem)[Dim.toLowerCase()]();
		
		var size = 'client' + Dim,
			html = elem.ownerDocument.documentElement,
			body = elem.ownerDocument.body;

		return Math.max( html[scroll], body[scroll] ) 
			 - Math.min( html[size]  , body[size]   );
	};

	function both( val ){
		return typeof val == 'object' ? val : { top:val, left:val };
	}

});
window.boxContextLoaded(function(jQuery) {

    var $ = jQuery;

    window.StickyTitles = function(stickies, horizonTop) {

        var init = function(sticky) {

            var thisSticky = $(sticky),
                outerHeight = thisSticky.outerHeight();

            // defer initialization until the sticky is visible
            if(thisSticky.is(':visible') === false || outerHeight === 0) {
                return;
            }

            thisSticky = $(sticky).wrap('<div class="mrb-sticky-header" />');

                thisSticky.parent().css({
                    'height': outerHeight + 'px',
                    'margin-bottom': thisSticky.css('margin-bottom')
                });
                thisSticky.css({
                    'margin-bottom': 0
                });

            $.data(thisSticky[0], 'initialized', true);
            $.data(thisSticky[0], 'pos', thisSticky.offset().top);
            $.data(thisSticky[0], 'offset', thisSticky.offsetParent().offset().top);
            $.data(thisSticky[0], 'horizonTop', typeof horizonTop !== 'undefined' ? horizonTop : 0);
        };

        this.load = function() {
            stickies.each(function(){

                init(this);
            });
        };

        this.scroll = function() {

            stickies.each(function(i) {
                var sticky = $(this),
                    initialized = $.data(sticky[0], 'initialized');

                if(initialized !== true) {
                    init(this);
                }

                if(initialized === true) {
                    if(sticky.css('position') !== 'fixed' && sticky.css('position') !== 'absolute') {
                      $.data(sticky[0], 'pos', sticky.offset().top);
                    }
                }
            });

            stickies.each(function(i) {

                var thisSticky = $(this),
                      nextSticky = stickies.eq(i+1),
                      prevSticky = stickies.eq(i-1),
                      pos = $.data(thisSticky[0], 'pos'),
                      windowTop = $(window).scrollTop() || null,
                      horizonTop = $.data(thisSticky[0], 'horizonTop'),
                      initialized = $.data(thisSticky[0], 'initialized');

                if(initialized === true) {
                    if (pos <= windowTop + horizonTop) {

                        thisSticky.addClass("mrb-sticky-header-fixed");

                        if(!thisSticky.hasClass("mrb-sticky-header-hidden")) {
                            setTimeout(function() {
                                thisSticky.addClass("mrb-sticky-header-hidden");
                            }, 0);
                        }

                        if (nextSticky.length > 0 && thisSticky.offset().top >= $.data(nextSticky[0], 'pos') - thisSticky.outerHeight()) {
                            thisSticky.addClass("mrb-sticky-header-absolute").css("top", $.data(nextSticky[0], 'pos') - thisSticky.outerHeight() - $.data(thisSticky[0], 'offset'));
                        }

                    } else {

                        thisSticky.removeClass("mrb-sticky-header-fixed");

                        if(thisSticky.hasClass("mrb-sticky-header-hidden")) {
                            setTimeout(function() {
                                thisSticky.removeClass("mrb-sticky-header-hidden");
                            }, 0);
                        }

                        if (prevSticky.length > 0 && windowTop <= $.data(thisSticky[0], 'pos')  - prevSticky.outerHeight()) {
                            prevSticky.removeClass("mrb-sticky-header-absolute").removeAttr("style");
                        }
                    }
                }
            });
        };

        this.add = function(elements) {

            elements.each(function(){

                init(this);
            });
            stickies = stickies.add(elements);
        };
    }
});
window.boxContextLoaded(function(jQuery) {

    var $ = jQuery;

    /*!
     * jQuery Cookie Plugin v1.4.0
     * https://github.com/carhartl/jquery-cookie
     *
     * Copyright 2013 Klaus Hartl
     * Released under the MIT license
     */
    (function(factory) {
//        if (typeof define === 'function' && define.amd) {
            // AMD. Register as anonymous module.
//            define(['jquery'], factory);
//        } else {
            // Browser globals.
            factory(jQuery);
//        }
    }(function($) {

        var pluses = /\+/g;

        function encode(s) {
            return config.raw ? s : encodeURIComponent(s);
        }

        function decode(s) {
            return config.raw ? s : decodeURIComponent(s);
        }

        function stringifyCookieValue(value) {
            return encode(config.json ? JSON.stringify(value) : String(value));
        }

        function parseCookieValue(s) {
            if (s.indexOf('"') === 0) {
                // This is a quoted cookie as according to RFC2068, unescape...
                s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
            }

            try {
                // Replace server-side written pluses with spaces.
                // If we can't decode the cookie, ignore it, it's unusable.
                s = decodeURIComponent(s.replace(pluses, ' '));
            } catch (e) {
                return;
            }

            try {
                // If we can't parse the cookie, ignore it, it's unusable.
                return config.json ? JSON.parse(s) : s;
            } catch (e) {
            }
        }

        function read(s, converter) {
            var value = config.raw ? s : parseCookieValue(s);
            return $.isFunction(converter) ? converter(value) : value;
        }

        var config = $.cookie = function(key, value, options) {

            // Write
            if (value !== undefined && !$.isFunction(value)) {
                options = $.extend({}, config.defaults, options);

                if (typeof options.expires === 'number') {
                    var days = options.expires, t = options.expires = new Date();
                    t.setDate(t.getDate() + days);
                }

                return (document.cookie = [
                    encode(key), '=', stringifyCookieValue(value),
                    options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                    options.path ? '; path=' + options.path : '',
                    options.domain ? '; domain=' + options.domain : '',
                    options.secure ? '; secure' : ''
                ].join(''));
            }

            // Read

            var result = key ? undefined : {};

            // To prevent the for loop in the first place assign an empty array
            // in case there are no cookies at all. Also prevents odd result when
            // calling $.cookie().
            var cookies = document.cookie ? document.cookie.split('; ') : [];

            for (var i = 0, l = cookies.length; i < l; i++) {
                var parts = cookies[i].split('=');
                var name = decode(parts.shift());
                var cookie = parts.join('=');

                if (key && key === name) {
                    // If second argument (value) is a function it's a converter...
                    result = read(cookie, value);
                    break;
                }

                // Prevent storing a cookie that we couldn't decode.
                if (!key && (cookie = read(cookie)) !== undefined) {
                    result[name] = cookie;
                }
            }

            return result;
        };

        config.defaults = {};

        $.removeCookie = function(key, options) {
            if ($.cookie(key) !== undefined) {
                // Must not alter options, thus extending a fresh object...
                $.cookie(key, '', $.extend({}, options, {expires: -1}));
                return true;
            }
            return false;
        };

    }));
});
/*
 * jQuery lazyLoad plugin, version 1.0 [2012-06-22]
 * Copyright 2012, Perfect Sense Digital, LLC
 * Author: Brendan Brelsford [brendanb@gmail.com]
 * Licensed under the MIT license [http://opensource.org/licenses/MIT]
 *
 * Usage:
 *
 *     Invocation
 *
 *     $('.classSelector').lazyLoad();
 *
 *     Invocation with $.Deferred chaining
 *
 *     $('.classSelector').lazyLoad().then(function() { ... });
 *
 * Events:
 *
 *     The lazyLoad plugin returns a $.Deferred, which covers the equivalent of a "complete" event.  In the specific case of lazy-loading images,
 *     an "error" event will be triggered on the <img> if the lazyLoad fails.  This allows the UI to respond to bad image URLs.  Since iframe loading
 *     doesn't provide an equivalent, the event will never be triggered for iframes.
 *
 * Options:
 *
 *     Options are passed as a flat javascript object with the following allowed keys:
 *
 *     "srcProp" - The HTML attribute in which the src value is stored.
 *                 Allowed Values: any non-empty string, although "data-" prefixed values are preferred not to conflict with reserved attribute names.
 *                 Default Value: "data-src"
 *
 *     "removeSrcProp" - Indicates whether the attribute keyed by "srcProp" should be removed after the lazyLoad has completed.  This does not affect
 *                 the behavior of lazyLoad when it is invoked multiple times on the same element.  It will always be called only once.
 *                 Allowed Values: true / false
 *                 Default Value: true
 *
 *     "descend" - Indicates whether to search for descendents of the current jQuery set that contain the attribute keyed by "srcProp" and lazy-load them.
 *                 Allowed Values: true / false
 *                 Default Value: true
 *
 *     "loadingClass" - CSS class applied to the objects to be loaded.  This class will be applied as soon as lazyLoad is called and removed from each
 *                 DOMNodeElement as it finishes loading.
 *                 Allowed Values: any non-empty string
 *                 Default Value: "loading"
 *
 *     "maxTimeout" - The time (in milliseconds) after which the $.Deferred returned by lazyLoad will resolve whether or not all pending loads have completed.
 *                 Allowed Values: integer > 0
 *                 Default Value: 1000
 *
 * Examples:
 *
 *     Add lazy-loading into a carousel / slide-show (e.g. Twitter bootstrap-carousel.js):
 *
 *     var context = this;
 *     var callback = function() { -- original code to show the slide at specified index -- };
 *     $toSlide.lazyLoad().then(function() {
 *        callback.call(context);
 *     });
 **/

window.boxContextLoaded(function(jQuery) {

    if (typeof jQuery !== 'undefined') {
        (function($) {

            $.fn.lazyLoad = function(opts) {

                var options = $.extend({
                    'srcProp': 'data-src',
                    'removeSrcProp': true,
                    'descend': true,
                    'loadingClass': 'loading',
                    'maxTimeout': 1000
                }, opts);

                /* Filter objects to only those that haven't yet been lazy-loaded */
                var $objects = $(this).filter(function(index) {
                    return !($(this).data('lazyLoad') === true);
                });

                /* If "descend" is set to true, find descendants with attribute "options.srcProp" */
                var $children = null;
                if(options.descend === true) {
                    $children = $objects.add($objects.find('[' + options.srcProp + ']'));
                }

                /* Further reduce the objects to only those that have attribute "options.srcProp" */
                $objects = $objects.filter('[' + options.srcProp + ']');

                /* Add children if any were found */
                if($children !== null && $children.size() > 0) {
                    $objects.add($children);
                }

                /* Set data to indicate that the image has been lazy-loaded.  This flag is set before
                 * any actual work is done to remove the potential for race conditions that might lead
                 * to one image being loaded twice. */
                $objects.data('lazyLoad', true);

                var dfdList = [];

                $objects.each(function() {

                    var $loadObject = $(this);
                    var src = $loadObject.attr('src');
                    var newSrc = $loadObject.attr(options.srcProp);

                    /* if the image has not been lazy-loaded and has a srcProp, proceed with loading */
                    if(newSrc != null) {

                        /* add a new deferred for this image to the array */
                        var dfd = new $.Deferred();
                        dfdList.push(dfd);

                        /* add loading class for CSS convenience */
                        $loadObject.addClass(options.loadingClass);

                        if($loadObject.is('img')) {

                            /* create an anonymous Image and define its load callback */
                            var i = new Image();
                            var $i = $(i);
                            $i.load(function() {

                                /* change src attribute to reflect the loaded srcProp */
                                $loadObject.attr('src', newSrc);

                                /* if "removeSrcProp" is set to true, remove the srcProp from the image element */
                                if(options.removeSrcProp) {
                                    $loadObject.removeAttr(options.srcProp);
                                }

                                /* delete the anonymous image */
                                delete(i);

                                /* remove CSS loading class */
                                $loadObject.removeClass(options.loadingClass);

                                /* resolve this image's deferred */
                                dfd.resolve();
                            });

                            $i.error(function() {
                                $loadObject.trigger('error');
                            });

                            /* initiate loading of this image by setting its src prop.
                             load callback will execute when loading is complete */
                            i.src = newSrc;
                        }

                        if($loadObject.is('iframe')) {

                            $loadObject.load(function() {

                                /* if "removeSrcProp" is set to true, remove the srcProp from the iframe element */
                                if(options.removeSrcProp) {
                                    $loadObject.removeAttr(options.srcProp);
                                }

                                /* remove CSS loading class */
                                $loadObject.removeClass(options.loadingClass);

                                /* resolve this image's deferred */
                                dfd.resolve();
                            });

                            $loadObject.attr('src', newSrc);
                        }
                    }
                });

                /* add timeout capability to returned deferred */
                var loadOrTimeout = new $.Deferred();

                /* when all images have loaded, resolve the returned deferred */
                $.when.apply(null, dfdList).then(function() {
                    loadOrTimeout.resolve();
                });

                /* alternatively, if a maxTimeout is defined, resolve the returned deferred after the specified timeout has expired */
                if(typeof(options.maxTimeout) === "number") {
                    setTimeout(function() {
                        loadOrTimeout.resolve();
                    }, options.maxTimeout);
                }

                /* return a deferred that will resolve after all images have loaded or after a specified timeout has expired */
                return loadOrTimeout;
            };
        })(jQuery);
    }
});
window.boxContextLoaded(function(jQuery) {

    var $ = jQuery;

    var DEBUG = SNI.BOX.DEBUG.forScope("HORIZONS");

    var calculateOffsetBottom = function($el, options) {

        if(options && options['windowSelector'] !== null) {
            var $window = $el.find(options['windowSelector']);
            if($window.size() === 1) {
                return $window.offset().top + $window.outerHeight();
            }
        }

        var offsetTop = parseInt(window.pageYOffset, 10);
        return offsetTop + window.innerHeight;
    };

    var loadImagesThenDisplay = function($el, options) {

        var $container;

        var $imgs = $el.filter('img[data-src]').add($el.find('img[data-src]')).not('.' + options['lazyLoadOptions']['loadingClass']);

        if($imgs.size() > 0) {

            DEBUG("Loading images: ", $imgs);
            $imgs.lazyLoad(options['lazyLoadOptions']).then(function() {

                if(options['lazyDisplaySelector'] !== null) {
                    $container = $imgs.closest(options['lazyDisplaySelector']);
                } else {
                    $container = $el;
                }

                SNI.BOX.DEBUG("then displaying: ", $container);

                $container.addClass(options['lazyDisplayTriggerClass']);
                $container.addClass(options['lazyDisplayHideClass']);
                lazyDisplayCallback($container, options);
            });
        }
    };

    var lazyDisplayCallback = function($el, options, offsetBottom) {

        if(typeof offsetBottom !== 'number') {
            offsetBottom = calculateOffsetBottom($el, options);
        }

        $el.filter('.' + options['lazyDisplayTriggerClass']).add($el.find('.' + options['lazyDisplayTriggerClass'])).each(function() {

            var $trigger = $(this);
            if($trigger.offset().top < offsetBottom + options['lazyDisplayBottomOffset']) {
                $trigger.removeClass(options['lazyDisplayTriggerClass']);
                $trigger.removeClass(options['lazyDisplayHideClass']);
            }
        });
    };

    var lazyLoadCallback = function($el, options, offsetBottom) {

        if(typeof offsetBottom !== 'number') {
            offsetBottom = calculateOffsetBottom($el, options);
        }

        var $links = $el.filter(options['paginationSelector']).add($el.find(options['paginationSelector']));

        $links.each(function() {

            var $link = $(this);
            var $frame = $link.closest('.' + options['frameClass']);

            if($frame.size() > 0 && $frame.hasClass(options['frameLoadingClass']) === false) {

                if($link.offset().top < (offsetBottom + options['lazyLoadBottomOffset'])) {

                    DEBUG("[horizons.js]: lazy loading pagination");

                    // TODO: replace with callback to do the loading business?
                    $link.click();
                }
            }
        })
    };

    var windowScrollers = [];
    var furthest = 0;

    $(window).on("scroll", $.throttle(50, function() {

        if(windowScrollers.length === 0) {
            return;
        }

        var offsetBottom = calculateOffsetBottom();

        if(offsetBottom > furthest) {

            furthest = offsetBottom;

            var i;
            for(i = 0; i < windowScrollers.length; i += 1) {

                $(windowScrollers[i]).each(function() {

                    var plugin = $(this).data('horizonsPlugin');

                    if(plugin.needsUpdate()) {
                        plugin.lazyLoad();
                        plugin.lazyDisplay();
                    }
                });
            }
        }
    }));

    function Horizons(el, options) {

        var plugin = this;

        // --- Defaults ---
        plugin['defaults'] = {
            'lazyLoadBottomOffset': 1200,
            'lazyDisplayBottomOffset': -150,
            'lazyDisplayTriggerClass': 'box-lazy-display-trigger',
            'lazyDisplaySelector': null,
            'lazyDisplayHideClass': 'box-lazy-display-hide',
            'lazyLoadOptions': {
                'maxTimeout': 1000, // 1 second
                'loadingClass': 'box-loading'
            },
            'windowSelector': null,
            'frameClass': 'dari-frame',
            'frameLoadingClass': 'dari-frame-loading',
            'frameLoadedClass': 'dari-frame-loaded',
            'paginationSelector': '.pagination'
        };

        // extend the default config with specified options
        plugin['config'] = $.extend(true, { }, this.defaults, options);

        // store a reference to the jQuery object
        plugin['$el'] = $(el);

        plugin['furthest'] = 0;

        // validate config & initialize

        plugin['$el'].on('endLoad', function() {
            loadImagesThenDisplay($(this), plugin['config']);
        });
    }

    Horizons.prototype = {

        options: function(options) {
            if(typeof options === 'object') {
                this.config = $.extend(true, { }, this['config'], options);
                return this.config;
            }
            return this.config;
        },
        update: function() {
            loadImagesThenDisplay(this['$el'], this['config']);
        },
        lazyDisplay: function(offsetBottom) {
            lazyDisplayCallback(this['$el'], this['config'], offsetBottom);
        },
        lazyLoad: function(offsetBottom) {
            lazyLoadCallback(this['$el'], this['config'], offsetBottom);
        },
        needsUpdate: function() {

            if(this['config']['windowSelector'] !== null) {
                return true;
            }

            var offsetBottom = calculateOffsetBottom(this['$el'], this['options']);
            if(offsetBottom > this['furthest']) {
                this['furthest'] = offsetBottom;
                return true;
            }

            return false;
        },
        window: function() {

            if(this['config']['windowSelector'] !== null) {
                var $window = this['$el'].find(this['config']['windowSelector']);
                if($window.size() === 1) {
                    return $window;
                } else {
                    $window = $(this['config']['windowSelector']);
                    if($window.size() === 1) {
                        return $window;
                    }
                }
            }
            return null;
        }
    };

    $.fn.horizons = function(methodName) {

        var $el = $(this);

        if(typeof methodName === 'undefined' || methodName === null || typeof methodName === 'object') {

            $el.each(function() {
                var $this = $(this);
                var plugin = new Horizons($this, methodName);
                lazyLoadCallback($this, plugin.options());
                loadImagesThenDisplay($this, plugin.options());

                if(plugin.window() !== null) {

                    plugin.window().on('scroll', function() {

                        plugin.lazyLoad();
                        plugin.lazyDisplay();
                    });
                } else {
                    windowScrollers.push($this);
                }

                $this.data('horizonsPlugin', plugin);
            });
        }

        var result;
        var methodArgs = arguments;

        if(typeof methodName === 'string') {
            $el.each(function() {
                var plugin = $(this).data('horizonsPlugin');
                if(typeof plugin[methodName] === 'function') {
                    var newResult = plugin[methodName].apply(plugin, Array.prototype.slice.call(methodArgs, 1));
                    if(typeof result === 'undefined') {
                        result = newResult;
                    }
                }
            });
        }

        return typeof result !== 'undefined' ? result : this;
    };
});
/* ========================================================================
 * Bootstrap: modal.js v3.1.1
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

window.boxContextLoaded(function(jQuery) {

    +function ($) {
    'use strict';

    // MODAL CLASS DEFINITION
    // ======================

    var Modal = function (element, options) {
        this.options        = options
        this.$body          = $(document.body)
        this.$element       = $(element)
        this.$backdrop      =
            this.isShown        = null
        this.scrollbarWidth = 0

        if (this.options.remote) {
            this.$element
                .find('.modal-content')
                .load(this.options.remote, $.proxy(function () {
                    this.$element.trigger('loaded.bs.modal')
                }, this))
        }
    }

    Modal.VERSION  = '3.1.1'

    Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
    }

    Modal.prototype.toggle = function (_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget)
    }

    Modal.prototype.show = function (_relatedTarget) {
        var that = this
        var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

        this.$element.trigger(e)

        if (this.isShown || e.isDefaultPrevented()) return

        this.isShown = true

        this.checkScrollbar()
        this.$body.addClass('modal-open')

        this.setScrollbar()
        this.escape()

        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

        this.backdrop(function () {
            var transition = $.support.transition && that.$element.hasClass('fade')

            if (!that.$element.parent().length) {
                that.$element.appendTo(that.$body) // don't move modals dom position
            }

            that.$element
                .show()
                .scrollTop(0)

            if (transition) {
                that.$element[0].offsetWidth // force reflow
            }

            that.$element
                .addClass('in')
                .attr('aria-hidden', false)

            that.enforceFocus()

            var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

            transition ?
                that.$element.find('.modal-dialog') // wait for modal to slide in
                    .one($.support.transition.end, function () {
                        that.$element.trigger('focus').trigger(e)
                    })
                    .emulateTransitionEnd(300) :
                that.$element.trigger('focus').trigger(e)
        })
    }

    Modal.prototype.hide = function (e) {
        if (e) e.preventDefault()

        e = $.Event('hide.bs.modal')

        this.$element.trigger(e)

        if (!this.isShown || e.isDefaultPrevented()) return

        this.isShown = false

        this.$body.removeClass('modal-open')

        this.resetScrollbar()
        this.escape()

        $(document).off('focusin.bs.modal')

        this.$element
            .removeClass('in')
            .attr('aria-hidden', true)
            .off('click.dismiss.bs.modal')

        $.support.transition && this.$element.hasClass('fade') ?
            this.$element
                .one($.support.transition.end, $.proxy(this.hideModal, this))
                .emulateTransitionEnd(300) :
            this.hideModal()
    }

    Modal.prototype.enforceFocus = function () {
        $(document)
            .off('focusin.bs.modal') // guard against infinite focus loop
            .on('focusin.bs.modal', $.proxy(function (e) {
                if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                    this.$element.trigger('focus')
                }
            }, this))
    }

    Modal.prototype.escape = function () {
        if (this.isShown && this.options.keyboard) {
            this.$element.on('keyup.dismiss.bs.modal', $.proxy(function (e) {
                e.which == 27 && this.hide()
            }, this))
        } else if (!this.isShown) {
            this.$element.off('keyup.dismiss.bs.modal')
        }
    }

    Modal.prototype.hideModal = function () {
        var that = this
        this.$element.hide()
        this.backdrop(function () {
            that.$element.trigger('hidden.bs.modal')
        })
    }

    Modal.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
    }

    Modal.prototype.backdrop = function (callback) {
        var that = this
        var animate = this.$element.hasClass('fade') ? 'fade' : ''

        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate

            this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
                .appendTo(this.$body)

            this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
                if (e.target !== e.currentTarget) return
                this.options.backdrop == 'static'
                    ? this.$element[0].focus.call(this.$element[0])
                    : this.hide.call(this)
            }, this))

            if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

            this.$backdrop.addClass('in')

            if (!callback) return

            doAnimate ?
                this.$backdrop
                    .one($.support.transition.end, callback)
                    .emulateTransitionEnd(150) :
                callback()

        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass('in')

            var callbackRemove = function () {
                that.removeBackdrop()
                callback && callback()
            }
            $.support.transition && this.$element.hasClass('fade') ?
                this.$backdrop
                    .one($.support.transition.end, callbackRemove)
                    .emulateTransitionEnd(150) :
                callbackRemove()

        } else if (callback) {
            callback()
        }
    }

    Modal.prototype.checkScrollbar = function () {
        if (document.body.clientWidth >= window.innerWidth) return
        this.scrollbarWidth = this.scrollbarWidth || this.measureScrollbar()
    }

    Modal.prototype.setScrollbar = function () {
        var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
        if (this.scrollbarWidth) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
    }

    Modal.prototype.resetScrollbar = function () {
        this.$body.css('padding-right', '')
    }

    Modal.prototype.measureScrollbar = function () { // thx walsh
        var scrollDiv = document.createElement('div')
        scrollDiv.className = 'modal-scrollbar-measure'
        this.$body.append(scrollDiv)
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
        this.$body[0].removeChild(scrollDiv)
        return scrollbarWidth
    }


    // MODAL PLUGIN DEFINITION
    // =======================

    function Plugin(option, _relatedTarget) {
        return this.each(function () {
            var $this   = $(this)
            var data    = $this.data('bs.modal')
            var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

            if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
            if (typeof option == 'string') data[option](_relatedTarget)
            else if (options.show) data.show(_relatedTarget)
        })
    }

    var old = $.fn.modal

    $.fn.modal             = Plugin
    $.fn.modal.Constructor = Modal


    // MODAL NO CONFLICT
    // =================

    $.fn.modal.noConflict = function () {
        $.fn.modal = old
        return this
    }


    // MODAL DATA-API
    // ==============

    $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
        var $this   = $(this)
        var href    = $this.attr('href')
        var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
        var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

        if ($this.is('a')) e.preventDefault()

        $target.one('show.bs.modal', function (showEvent) {
            if (showEvent.isDefaultPrevented()) return  // only register focus restorer if modal will actually get shown
            $target.one('hidden.bs.modal', function () {
                $this.is(':visible') && $this.trigger('focus')
            })
        })
        Plugin.call($target, option, this)
    })

    }(jQuery);
});
/* ========================================================================
 * Bootstrap: dropdown.js v3.1.1
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

window.boxContextLoaded(function(jQuery) {
    var $ = jQuery;

    +function ($) {
        'use strict';

        // DROPDOWN CLASS DEFINITION
        // =========================

        var backdrop = '.dropdown-backdrop'
        var toggle   = '[data-toggle="dropdown"]'
        var Dropdown = function (element) {
            $(element).on('click.bs.dropdown', this.toggle)
        }

        Dropdown.VERSION = '3.1.1'

        Dropdown.prototype.toggle = function (e) {
            var $this = $(this)

            if ($this.is('.disabled, :disabled')) return

            var $parent  = getParent($this)
            var isActive = $parent.hasClass('open')

            clearMenus()

            if (!isActive) {
                if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
                    // if mobile we use a backdrop because click events don't delegate
                    $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
                }

                var relatedTarget = { relatedTarget: this }
                $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

                if (e.isDefaultPrevented()) return

                $this.trigger('focus')

                $parent
                    .toggleClass('open')
                    .trigger('shown.bs.dropdown', relatedTarget)
            }

            return false
        }

        Dropdown.prototype.keydown = function (e) {
            if (!/(38|40|27)/.test(e.keyCode)) return

            var $this = $(this)

            e.preventDefault()
            e.stopPropagation()

            if ($this.is('.disabled, :disabled')) return

            var $parent  = getParent($this)
            var isActive = $parent.hasClass('open')

            if (!isActive || (isActive && e.keyCode == 27)) {
                if (e.which == 27) $parent.find(toggle).trigger('focus')
                return $this.trigger('click')
            }

            var desc = ' li:not(.divider):visible a'
            var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)

            if (!$items.length) return

            var index = $items.index($items.filter(':focus'))

            if (e.keyCode == 38 && index > 0)                 index--                        // up
            if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
            if (!~index)                                      index = 0

            $items.eq(index).trigger('focus')
        }

        function clearMenus(e) {
            if (e && e.which === 3) return
            $(backdrop).remove()
            $(toggle).each(function () {
                var $parent = getParent($(this))
                var relatedTarget = { relatedTarget: this }
                if (!$parent.hasClass('open')) return
                $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))
                if (e.isDefaultPrevented()) return
                $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
            })
        }

        function getParent($this) {
            var selector = $this.attr('data-target')

            if (!selector) {
                selector = $this.attr('href')
                selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
            }

            var $parent = selector && $(selector)

            return $parent && $parent.length ? $parent : $this.parent()
        }


        // DROPDOWN PLUGIN DEFINITION
        // ==========================

        function Plugin(option) {
            return this.each(function () {
                var $this = $(this)
                var data  = $this.data('bs.dropdown')

                if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
                if (typeof option == 'string') data[option].call($this)
            })
        }

        var old = $.fn.dropdown

        $.fn.dropdown             = Plugin
        $.fn.dropdown.Constructor = Dropdown


        // DROPDOWN NO CONFLICT
        // ====================

        $.fn.dropdown.noConflict = function () {
            $.fn.dropdown = old
            return this
        }


        // APPLY TO STANDARD DROPDOWN ELEMENTS
        // ===================================

        $(document)
            .on('click.bs.dropdown.data-api', clearMenus)
            .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
            .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
            .on('keydown.bs.dropdown.data-api', toggle + ', [role="menu"], [role="listbox"]', Dropdown.prototype.keydown)

    }(jQuery);
});
/* ========================================================================
 * Bootstrap: modal.js v3.1.1
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

window.boxContextLoaded(function(jQuery) {

    +function ($) {
    'use strict';

    // MODAL CLASS DEFINITION
    // ======================

    var Modal = function (element, options) {
        this.options        = options
        this.$body          = $(document.body)
        this.$element       = $(element)
        this.$backdrop      =
            this.isShown        = null
        this.scrollbarWidth = 0

        if (this.options.remote) {
            this.$element
                .find('.modal-content')
                .load(this.options.remote, $.proxy(function () {
                    this.$element.trigger('loaded.bs.modal')
                }, this))
        }
    }

    Modal.VERSION  = '3.1.1'

    Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
    }

    Modal.prototype.toggle = function (_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget)
    }

    Modal.prototype.show = function (_relatedTarget) {
        var that = this
        var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

        this.$element.trigger(e)

        if (this.isShown || e.isDefaultPrevented()) return

        this.isShown = true

        this.checkScrollbar()
        this.$body.addClass('modal-open')

        this.setScrollbar()
        this.escape()

        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

        this.backdrop(function () {
            var transition = $.support.transition && that.$element.hasClass('fade')

            if (!that.$element.parent().length) {
                that.$element.appendTo(that.$body) // don't move modals dom position
            }

            that.$element
                .show()
                .scrollTop(0)

            if (transition) {
                that.$element[0].offsetWidth // force reflow
            }

            that.$element
                .addClass('in')
                .attr('aria-hidden', false)

            that.enforceFocus()

            var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

            transition ?
                that.$element.find('.modal-dialog') // wait for modal to slide in
                    .one($.support.transition.end, function () {
                        that.$element.trigger('focus').trigger(e)
                    })
                    .emulateTransitionEnd(300) :
                that.$element.trigger('focus').trigger(e)
        })
    }

    Modal.prototype.hide = function (e) {
        if (e) e.preventDefault()

        e = $.Event('hide.bs.modal')

        this.$element.trigger(e)

        if (!this.isShown || e.isDefaultPrevented()) return

        this.isShown = false

        this.$body.removeClass('modal-open')

        this.resetScrollbar()
        this.escape()

        $(document).off('focusin.bs.modal')

        this.$element
            .removeClass('in')
            .attr('aria-hidden', true)
            .off('click.dismiss.bs.modal')

        $.support.transition && this.$element.hasClass('fade') ?
            this.$element
                .one($.support.transition.end, $.proxy(this.hideModal, this))
                .emulateTransitionEnd(300) :
            this.hideModal()
    }

    Modal.prototype.enforceFocus = function () {
        $(document)
            .off('focusin.bs.modal') // guard against infinite focus loop
            .on('focusin.bs.modal', $.proxy(function (e) {
                if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                    this.$element.trigger('focus')
                }
            }, this))
    }

    Modal.prototype.escape = function () {
        if (this.isShown && this.options.keyboard) {
            this.$element.on('keyup.dismiss.bs.modal', $.proxy(function (e) {
                e.which == 27 && this.hide()
            }, this))
        } else if (!this.isShown) {
            this.$element.off('keyup.dismiss.bs.modal')
        }
    }

    Modal.prototype.hideModal = function () {
        var that = this
        this.$element.hide()
        this.backdrop(function () {
            that.$element.trigger('hidden.bs.modal')
        })
    }

    Modal.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
    }

    Modal.prototype.backdrop = function (callback) {
        var that = this
        var animate = this.$element.hasClass('fade') ? 'fade' : ''

        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate

            this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
                .appendTo(this.$body)

            this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
                if (e.target !== e.currentTarget) return
                this.options.backdrop == 'static'
                    ? this.$element[0].focus.call(this.$element[0])
                    : this.hide.call(this)
            }, this))

            if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

            this.$backdrop.addClass('in')

            if (!callback) return

            doAnimate ?
                this.$backdrop
                    .one($.support.transition.end, callback)
                    .emulateTransitionEnd(150) :
                callback()

        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass('in')

            var callbackRemove = function () {
                that.removeBackdrop()
                callback && callback()
            }
            $.support.transition && this.$element.hasClass('fade') ?
                this.$backdrop
                    .one($.support.transition.end, callbackRemove)
                    .emulateTransitionEnd(150) :
                callbackRemove()

        } else if (callback) {
            callback()
        }
    }

    Modal.prototype.checkScrollbar = function () {
        if (document.body.clientWidth >= window.innerWidth) return
        this.scrollbarWidth = this.scrollbarWidth || this.measureScrollbar()
    }

    Modal.prototype.setScrollbar = function () {
        var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
        if (this.scrollbarWidth) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
    }

    Modal.prototype.resetScrollbar = function () {
        this.$body.css('padding-right', '')
    }

    Modal.prototype.measureScrollbar = function () { // thx walsh
        var scrollDiv = document.createElement('div')
        scrollDiv.className = 'modal-scrollbar-measure'
        this.$body.append(scrollDiv)
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
        this.$body[0].removeChild(scrollDiv)
        return scrollbarWidth
    }


    // MODAL PLUGIN DEFINITION
    // =======================

    function Plugin(option, _relatedTarget) {
        return this.each(function () {
            var $this   = $(this)
            var data    = $this.data('bs.modal')
            var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

            if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
            if (typeof option == 'string') data[option](_relatedTarget)
            else if (options.show) data.show(_relatedTarget)
        })
    }

    var old = $.fn.modal

    $.fn.modal             = Plugin
    $.fn.modal.Constructor = Modal


    // MODAL NO CONFLICT
    // =================

    $.fn.modal.noConflict = function () {
        $.fn.modal = old
        return this
    }


    // MODAL DATA-API
    // ==============

    $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
        var $this   = $(this)
        var href    = $this.attr('href')
        var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
        var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

        if ($this.is('a')) e.preventDefault()

        $target.one('show.bs.modal', function (showEvent) {
            if (showEvent.isDefaultPrevented()) return  // only register focus restorer if modal will actually get shown
            $target.one('hidden.bs.modal', function () {
                $this.is(':visible') && $this.trigger('focus')
            })
        })
        Plugin.call($target, option, this)
    })

    }(jQuery);
});
/*!
 * bootstrap-select v1.5.4
 * http://silviomoreto.github.io/bootstrap-select/
 *
 * Copyright 2013 bootstrap-select
 * Licensed under the MIT license
 */

window.boxContextLoaded(function(jQuery) {
    var $ = jQuery;

    !function($) {

        'use strict';

        $.expr[':'].icontains = function(obj, index, meta) {
            return $(obj).text().toUpperCase().indexOf(meta[3].toUpperCase()) >= 0;
        };

        var Selectpicker = function(element, options, e) {
            if (e) {
                e.stopPropagation();
                e.preventDefault();
            }
            this.$element = $(element);
            this.$newElement = null;
            this.$button = null;
            this.$menu = null;
            this.$lis = null;

            //Merge defaults, options and data-attributes to make our options
            this.options = $.extend({}, $.fn.selectpicker.defaults, this.$element.data(), typeof options == 'object' && options);

            //If we have no title yet, check the attribute 'title' (this is missed by jq as its not a data-attribute
            if (this.options.title === null) {
                this.options.title = this.$element.attr('title');
            }

            //Expose public methods
            this.val = Selectpicker.prototype.val;
            this.render = Selectpicker.prototype.render;
            this.refresh = Selectpicker.prototype.refresh;
            this.setStyle = Selectpicker.prototype.setStyle;
            this.selectAll = Selectpicker.prototype.selectAll;
            this.deselectAll = Selectpicker.prototype.deselectAll;
            this.init();
        };

        Selectpicker.prototype = {

            constructor: Selectpicker,

            init: function() {
                var that = this,
                    id = this.$element.attr('id');

                this.$element.hide();
                this.multiple = this.$element.prop('multiple');
                this.autofocus = this.$element.prop('autofocus');
                this.$newElement = this.createView();
                this.$element.after(this.$newElement);
                this.$menu = this.$newElement.find('> .dropdown-menu');
                this.$button = this.$newElement.find('> button');
                this.$searchbox = this.$newElement.find('input');

                if (id !== undefined) {
                    this.$button.attr('data-id', id);
                    $('label[for="' + id + '"]').click(function(e) {
                        e.preventDefault();
                        that.$button.focus();
                    });
                }

                this.checkDisabled();
                this.clickListener();
                if (this.options.liveSearch) this.liveSearchListener();
                this.render();
                this.liHeight();
                this.setStyle();
                this.setWidth();
                if (this.options.container) this.selectPosition();
                this.$menu.data('this', this);
                this.$newElement.data('this', this);
            },

            createDropdown: function() {
                //If we are multiple, then add the show-tick class by default
                var multiple = this.multiple ? ' show-tick' : '';
                var inputGroup = this.$element.parent().hasClass('input-group') ? ' input-group-btn' : '';
                var autofocus = this.autofocus ? ' autofocus' : '';
                var header = this.options.header ? '<div class="popover-title"><button type="button" class="close" aria-hidden="true">&times;</button>' + this.options.header + '</div>' : '';
                var searchbox = this.options.liveSearch ? '<div class="bootstrap-select-searchbox"><input type="text" class="input-block-level form-control" autocomplete="off" /></div>' : '';
                var actionsbox = this.options.actionsBox ? '<div class="bs-actionsbox">' +
                    '<div class="btn-group btn-block">' +
                    '<button class="actions-btn bs-select-all btn btn-sm btn-default">' +
                    'Select All' +
                    '</button>' +
                    '<button class="actions-btn bs-deselect-all btn btn-sm btn-default">' +
                    'Deselect All' +
                    '</button>' +
                    '</div>' +
                    '</div>' : '';
                var drop =
                    '<div class="btn-group bootstrap-select' + multiple + inputGroup + '">' +
                    '<button type="button" class="btn dropdown-toggle selectpicker" data-toggle="dropdown"'+ autofocus +'>' +
                    '<span class="filter-option pull-left"></span>&nbsp;' +
                    '<span class="icon icon-angle-down"></span>' +
                    '</button>' +
                    '<div class="dropdown-menu open">' +
                    header +
                    searchbox +
                    actionsbox +
                    '<ul class="dropdown-menu inner selectpicker" role="menu">' +
                    '</ul>' +
                    '</div>' +
                    '</div>';

                return $(drop);
            },

            createView: function() {
                var $drop = this.createDropdown();
                var $li = this.createLi();
                $drop.find('ul').append($li);
                return $drop;
            },

            reloadLi: function() {
                //Remove all children.
                this.destroyLi();
                //Re build
                var $li = this.createLi();
                this.$menu.find('ul').append( $li );
            },

            destroyLi: function() {
                this.$menu.find('li').remove();
            },

            createLi: function() {
                var that = this,
                    _liA = [],
                    _liHtml = '';

                this.$element.find('option').each(function() {
                    var $this = $(this);

                    //Get the class and text for the option
                    var optionClass = $this.attr('class') || '';
                    var inline = $this.attr('style') || '';
                    var text =  $this.data('content') ? $this.data('content') : $this.html();
                    var subtext = $this.data('subtext') !== undefined ? '<small class="muted text-muted">' + $this.data('subtext') + '</small>' : '';
                    var icon = $this.data('icon') !== undefined ? '<i class="' + that.options.iconBase + ' ' + $this.data('icon') + '"></i> ' : '';
                    if (icon !== '' && ($this.is(':disabled') || $this.parent().is(':disabled'))) {
                        icon = '<span>'+icon+'</span>';
                    }

                    if (!$this.data('content')) {
                        //Prepend any icon and append any subtext to the main text.
                        text = icon + '<span class="text">' + text + subtext + '</span>';
                    }

                    if (that.options.hideDisabled && ($this.is(':disabled') || $this.parent().is(':disabled'))) {
                        _liA.push('<a style="min-height: 0; padding: 0"></a>');
                    } else if ($this.parent().is('optgroup') && $this.data('divider') !== true) {
                        if ($this.index() === 0) {
                            //Get the opt group label
                            var label = $this.parent().attr('label');
                            var labelSubtext = $this.parent().data('subtext') !== undefined ? '<small class="muted text-muted">'+$this.parent().data('subtext')+'</small>' : '';
                            var labelIcon = $this.parent().data('icon') ? '<i class="'+$this.parent().data('icon')+'"></i> ' : '';
                            label = labelIcon + '<span class="text">' + label + labelSubtext + '</span>';

                            if ($this[0].index !== 0) {
                                _liA.push(
                                        '<div class="div-contain"><div class="divider"></div></div>'+
                                        '<dt>'+label+'</dt>'+
                                        that.createA(text, 'opt ' + optionClass, inline )
                                );
                            } else {
                                _liA.push(
                                        '<dt>'+label+'</dt>'+
                                        that.createA(text, 'opt ' + optionClass, inline ));
                            }
                        } else {
                            _liA.push(that.createA(text, 'opt ' + optionClass, inline ));
                        }
                    } else if ($this.data('divider') === true) {
                        _liA.push('<div class="div-contain"><div class="divider"></div></div>');
                    } else if ($(this).data('hidden') === true) {
                        _liA.push('<a></a>');
                    } else {
                        _liA.push(that.createA(text, optionClass, inline ));
                    }
                });

                $.each(_liA, function(i, item) {
                    var hide = item === '<a></a>' ? 'class="hide is-hidden"' : '';
                    _liHtml += '<li rel="' + i + '"' + hide + '>' + item + '</li>';
                });

                //If we are not multiple, and we dont have a selected item, and we dont have a title, select the first element so something is set in the button
                if (!this.multiple && this.$element.find('option:selected').length===0 && !this.options.title) {
                    this.$element.find('option').eq(0).prop('selected', true).attr('selected', 'selected');
                }

                return $(_liHtml);
            },

            createA: function(text, classes, inline) {
                return '<a tabindex="0" class="'+classes+'" style="'+inline+'">' +
                    text +
                    '<i class="' + this.options.iconBase + ' ' + this.options.tickIcon + ' icon-ok check-mark"></i>' +
                    '</a>';
            },

            render: function(updateLi) {
                var that = this;

                //Update the LI to match the SELECT
                if (updateLi !== false) {
                    this.$element.find('option').each(function(index) {
                        that.setDisabled(index, $(this).is(':disabled') || $(this).parent().is(':disabled') );
                        that.setSelected(index, $(this).is(':selected') );
                    });
                }

                this.tabIndex();

                var selectedItems = this.$element.find('option:selected').map(function() {
                    var $this = $(this);
                    var icon = $this.data('icon') && that.options.showIcon ? '<i class="' + that.options.iconBase + ' ' + $this.data('icon') + '"></i> ' : '';
                    var subtext;
                    if (that.options.showSubtext && $this.attr('data-subtext') && !that.multiple) {
                        subtext = ' <small class="muted text-muted">'+$this.data('subtext') +'</small>';
                    } else {
                        subtext = '';
                    }
                    if ($this.data('content') && that.options.showContent) {
                        return $this.data('content');
                    } else if ($this.attr('title') !== undefined) {
                        return $this.attr('title');
                    } else {
                        return icon + $this.html() + subtext;
                    }
                }).toArray();

                //Fixes issue in IE10 occurring when no default option is selected and at least one option is disabled
                //Convert all the values into a comma delimited string
                var title = !this.multiple ? selectedItems[0] : selectedItems.join(this.options.multipleSeparator);

                //If this is multi select, and the selectText type is count, the show 1 of 2 selected etc..
                if (this.multiple && this.options.selectedTextFormat.indexOf('count') > -1) {
                    var max = this.options.selectedTextFormat.split('>');
                    var notDisabled = this.options.hideDisabled ? ':not([disabled])' : '';
                    if ( (max.length>1 && selectedItems.length > max[1]) || (max.length==1 && selectedItems.length>=2)) {
                        title = this.options.countSelectedText.replace('{0}', selectedItems.length).replace('{1}', this.$element.find('option:not([data-divider="true"]):not([data-hidden="true"])'+notDisabled).length);
                    }
                }

                this.options.title = this.$element.attr('title');

                //If we dont have a title, then use the default, or if nothing is set at all, use the not selected text
                if (!title) {
                    title = this.options.title !== undefined ? this.options.title : this.options.noneSelectedText;
                }

                this.$button.attr('title', $.trim(title));
                this.$newElement.find('.filter-option').html(title);
            },

            setStyle: function(style, status) {
                if (this.$element.attr('class')) {
                    this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|validate\[.*\]/gi, ''));
                }

                var buttonClass = style ? style : this.options.style;

                if (status == 'add') {
                    this.$button.addClass(buttonClass);
                } else if (status == 'remove') {
                    this.$button.removeClass(buttonClass);
                } else {
                    this.$button.removeClass(this.options.style);
                    this.$button.addClass(buttonClass);
                }
            },

            liHeight: function() {
                if (this.options.size === false) return;

                var $selectClone = this.$menu.parent().clone().find('> .dropdown-toggle').prop('autofocus', false).end().appendTo('body'),
                    $menuClone = $selectClone.addClass('open').find('> .dropdown-menu'),
                    liHeight = $menuClone.find('li > a').outerHeight(),
                    headerHeight = this.options.header ? $menuClone.find('.popover-title').outerHeight() : 0,
                    searchHeight = this.options.liveSearch ? $menuClone.find('.bootstrap-select-searchbox').outerHeight() : 0,
                    actionsHeight = this.options.actionsBox ? $menuClone.find('.bs-actionsbox').outerHeight() : 0;

                $selectClone.remove();

                this.$newElement
                    .data('liHeight', liHeight)
                    .data('headerHeight', headerHeight)
                    .data('searchHeight', searchHeight)
                    .data('actionsHeight', actionsHeight);
            },

            setSize: function() {
                var that = this,
                    menu = this.$menu,
                    menuInner = menu.find('.inner'),
                    selectHeight = this.$newElement.outerHeight(),
                    liHeight = this.$newElement.data('liHeight'),
                    headerHeight = this.$newElement.data('headerHeight'),
                    searchHeight = this.$newElement.data('searchHeight'),
                    actionsHeight = this.$newElement.data('actionsHeight'),
                    divHeight = menu.find('li .divider').outerHeight(true),
                    menuPadding = parseInt(menu.css('padding-top')) +
                        parseInt(menu.css('padding-bottom')) +
                        parseInt(menu.css('border-top-width')) +
                        parseInt(menu.css('border-bottom-width')),
                    notDisabled = this.options.hideDisabled ? ':not(.disabled)' : '',
                    $window = $(window),
                    menuExtras = menuPadding + parseInt(menu.css('margin-top')) + parseInt(menu.css('margin-bottom')) + 2,
                    menuHeight,
                    selectOffsetTop,
                    selectOffsetBot,
                    posVert = function() {
                        selectOffsetTop = that.$newElement.offset().top - $window.scrollTop();
                        selectOffsetBot = $window.height() - selectOffsetTop - selectHeight;
                    };
                posVert();
                if (this.options.header) menu.css('padding-top', 0);

                if (this.options.size == 'auto') {
                    var getSize = function() {
                        var minHeight,
                            lisVis = that.$lis.not('.hide');

                        posVert();
                        menuHeight = selectOffsetBot - menuExtras;

                        if (that.options.dropupAuto) {
                            that.$newElement.toggleClass('dropup', (selectOffsetTop > selectOffsetBot) && ((menuHeight - menuExtras) < menu.height()));
                        }
                        if (that.$newElement.hasClass('dropup')) {
                            menuHeight = selectOffsetTop - menuExtras;
                        }

                        if ((lisVis.length + lisVis.find('dt').length) > 3) {
                            minHeight = liHeight*3 + menuExtras - 2;
                        } else {
                            minHeight = 0;
                        }

                        menu.css({'max-height' : menuHeight + 'px', 'overflow' : 'hidden', 'min-height' : minHeight + headerHeight + searchHeight + actionsHeight + 'px'});
                        menuInner.css({'max-height' : menuHeight - headerHeight - searchHeight - actionsHeight - menuPadding + 'px', 'overflow-y' : 'auto', 'min-height' : Math.max(minHeight - menuPadding, 0) + 'px'});
                    };
                    getSize();
                    this.$searchbox.off('input.getSize propertychange.getSize').on('input.getSize propertychange.getSize', getSize);
                    $(window).off('resize.getSize').on('resize.getSize', getSize);
                    $(window).off('scroll.getSize').on('scroll.getSize', getSize);
                } else if (this.options.size && this.options.size != 'auto' && menu.find('li'+notDisabled).length > this.options.size) {
                    var optIndex = menu.find('li'+notDisabled+' > *').filter(':not(.div-contain)').slice(0,this.options.size).last().parent().index();
                    var divLength = menu.find('li').slice(0,optIndex + 1).find('.div-contain').length;
                    menuHeight = liHeight*this.options.size + divLength*divHeight + menuPadding;
                    if (that.options.dropupAuto) {
                        this.$newElement.toggleClass('dropup', (selectOffsetTop > selectOffsetBot) && (menuHeight < menu.height()));
                    }
                    menu.css({'max-height' : menuHeight + headerHeight + searchHeight + actionsHeight + 'px', 'overflow' : 'hidden'});
                    menuInner.css({'max-height' : menuHeight - menuPadding + 'px', 'overflow-y' : 'auto'});
                }
            },

            setWidth: function() {
                if (this.options.width == 'auto') {
                    this.$menu.css('min-width', '0');

                    // Get correct width if element hidden
                    var selectClone = this.$newElement.clone().appendTo('body');
                    var ulWidth = selectClone.find('> .dropdown-menu').css('width');
                    var btnWidth = selectClone.css('width', 'auto').find('> button').css('width');
                    selectClone.remove();

                    // Set width to whatever's larger, button title or longest option
                    this.$newElement.css('width', Math.max(parseInt(ulWidth), parseInt(btnWidth)) + 'px');
                } else if (this.options.width == 'fit') {
                    // Remove inline min-width so width can be changed from 'auto'
                    this.$menu.css('min-width', '');
                    this.$newElement.css('width', '').addClass('fit-width');
                } else if (this.options.width) {
                    // Remove inline min-width so width can be changed from 'auto'
                    this.$menu.css('min-width', '');
                    this.$newElement.css('width', this.options.width);
                } else {
                    // Remove inline min-width/width so width can be changed
                    this.$menu.css('min-width', '');
                    this.$newElement.css('width', '');
                }
                // Remove fit-width class if width is changed programmatically
                if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {
                    this.$newElement.removeClass('fit-width');
                }
            },

            selectPosition: function() {
                var that = this,
                    drop = '<div />',
                    $drop = $(drop),
                    pos,
                    actualHeight,
                    getPlacement = function($element) {
                        $drop.addClass($element.attr('class').replace(/form-control/gi, '')).toggleClass('dropup', $element.hasClass('dropup'));
                        pos = $element.offset();
                        actualHeight = $element.hasClass('dropup') ? 0 : $element[0].offsetHeight;
                        $drop.css({'top' : pos.top + actualHeight, 'left' : pos.left, 'width' : $element[0].offsetWidth, 'position' : 'absolute'});
                    };
                this.$newElement.on('click', function() {
                    if (that.isDisabled()) {
                        return;
                    }
                    getPlacement($(this));
                    $drop.appendTo(that.options.container);
                    $drop.toggleClass('open', !$(this).hasClass('open'));
                    $drop.append(that.$menu);
                });
                $(window).resize(function() {
                    getPlacement(that.$newElement);
                });
                $(window).on('scroll', function() {
                    getPlacement(that.$newElement);
                });
                $('html').on('click', function(e) {
                    if ($(e.target).closest(that.$newElement).length < 1) {
                        $drop.removeClass('open');
                    }
                });
            },

            mobile: function() {
                this.$element.addClass('mobile-device').appendTo(this.$newElement);
                if (this.options.container) this.$menu.hide();
            },

            refresh: function() {
                this.$lis = null;
                this.reloadLi();
                this.render();
                this.setWidth();
                this.setStyle();
                this.checkDisabled();
                this.liHeight();
            },

            update: function() {
                this.reloadLi();
                this.setWidth();
                this.setStyle();
                this.checkDisabled();
                this.liHeight();
            },

            setSelected: function(index, selected) {
                if (this.$lis == null) this.$lis = this.$menu.find('li');
                $(this.$lis[index]).toggleClass('selected', selected);
            },

            setDisabled: function(index, disabled) {
                if (this.$lis == null) this.$lis = this.$menu.find('li');
                if (disabled) {
                    $(this.$lis[index]).addClass('disabled').find('a').attr('href', '#').attr('tabindex', -1);
                } else {
                    $(this.$lis[index]).removeClass('disabled').find('a').removeAttr('href').attr('tabindex', 0);
                }
            },

            isDisabled: function() {
                return this.$element.is(':disabled');
            },

            checkDisabled: function() {
                var that = this;

                if (this.isDisabled()) {
                    this.$button.addClass('disabled').attr('tabindex', -1);
                } else {
                    if (this.$button.hasClass('disabled')) {
                        this.$button.removeClass('disabled');
                    }

                    if (this.$button.attr('tabindex') == -1) {
                        if (!this.$element.data('tabindex')) this.$button.removeAttr('tabindex');
                    }
                }

                this.$button.click(function() {
                    return !that.isDisabled();
                });
            },

            tabIndex: function() {
                if (this.$element.is('[tabindex]')) {
                    this.$element.data('tabindex', this.$element.attr('tabindex'));
                    this.$button.attr('tabindex', this.$element.data('tabindex'));
                }
            },

            clickListener: function() {
                var that = this;

                $('body').on('touchstart.dropdown', '.dropdown-menu', function(e) {
                    e.stopPropagation();
                });

                this.$newElement.on('click', function() {
                    that.setSize();
                    if (!that.options.liveSearch && !that.multiple) {
                        setTimeout(function() {
                            that.$menu.find('.selected a').focus();
                        }, 10);
                    }
                });

                this.$menu.on('click', 'li a', function(e) {
                    var clickedIndex = $(this).parent().index(),
                        prevValue = that.$element.val(),
                        prevIndex = that.$element.prop('selectedIndex');

                    //Dont close on multi choice menu
                    if (that.multiple) {
                        e.stopPropagation();
                    }

                    e.preventDefault();

                    //Dont run if we have been disabled
                    if (!that.isDisabled() && !$(this).parent().hasClass('disabled')) {
                        var $options = that.$element.find('option'),
                            $option = $options.eq(clickedIndex),
                            state = $option.prop('selected'),
                            $optgroup = $option.parent('optgroup'),
                            maxOptions = that.options.maxOptions,
                            maxOptionsGrp = $optgroup.data('maxOptions') || false;

                        //Deselect all others if not multi select box
                        if (!that.multiple) {
                            $options.prop('selected', false);
                            $option.prop('selected', true);
                            that.$menu.find('.selected').removeClass('selected');
                            that.setSelected(clickedIndex, true);
                        }
                        //Else toggle the one we have chosen if we are multi select.
                        else {
                            $option.prop('selected', !state);
                            that.setSelected(clickedIndex, !state);

                            if ((maxOptions !== false) || (maxOptionsGrp !== false)) {
                                var maxReached = maxOptions < $options.filter(':selected').length,
                                    maxReachedGrp = maxOptionsGrp < $optgroup.find('option:selected').length,
                                    maxOptionsArr = that.options.maxOptionsText,
                                    maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),
                                    maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),
                                    $notify = $('<div class="notify"></div>');

                                if ((maxOptions && maxReached) || (maxOptionsGrp && maxReachedGrp)) {
                                    // If {var} is set in array, replace it
                                    if (maxOptionsArr[2]) {
                                        maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);
                                        maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);
                                    }

                                    $option.prop('selected', false);

                                    that.$menu.append($notify);

                                    if (maxOptions && maxReached) {
                                        $notify.append($('<div>' + maxTxt + '</div>'));
                                        that.$element.trigger('maxReached.bs.select');
                                    }

                                    if (maxOptionsGrp && maxReachedGrp) {
                                        $notify.append($('<div>' + maxTxtGrp + '</div>'));
                                        that.$element.trigger('maxReachedGrp.bs.select');
                                    }

                                    setTimeout(function() {
                                        that.setSelected(clickedIndex, false);
                                    }, 10);

                                    $notify.delay(750).fadeOut(300, function() { $(this).remove(); });
                                }
                            }
                        }

                        if (!that.multiple) {
                            that.$button.focus();
                        } else if (that.options.liveSearch) {
                            that.$searchbox.focus();
                        }

                        // Trigger select 'change'
                        if ((prevValue != that.$element.val() && that.multiple) || (prevIndex != that.$element.prop('selectedIndex') && !that.multiple)) {
                            that.$element.change();
                        }
                    }
                });

                this.$menu.on('click', 'li.disabled a, li dt, li .div-contain, .popover-title, .popover-title :not(.close)', function(e) {
                    if (e.target == this) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!that.options.liveSearch) {
                            that.$button.focus();
                        } else {
                            that.$searchbox.focus();
                        }
                    }
                });

                this.$menu.on('click', '.popover-title .close', function() {
                    that.$button.focus();
                });

                this.$searchbox.on('click', function(e) {
                    e.stopPropagation();
                });


                this.$menu.on('click', '.actions-btn', function(e) {
                    if (that.options.liveSearch) {
                        that.$searchbox.focus();
                    } else {
                        that.$button.focus();
                    }

                    e.preventDefault();
                    e.stopPropagation();

                    if ($(this).is('.bs-select-all')) {
                        that.selectAll();
                    } else {
                        that.deselectAll();
                    }
                    that.$element.change();
                });

                this.$element.change(function() {
                    that.render(false);
                });
            },

            liveSearchListener: function() {
                var that = this,
                    no_results = $('<li class="no-results"></li>');

                this.$newElement.on('click.dropdown.data-api', function() {
                    that.$menu.find('.active').removeClass('active');
                    if (!!that.$searchbox.val()) {
                        that.$searchbox.val('');
                        that.$lis.not('.is-hidden').removeClass('hide');
                        if (!!no_results.parent().length) no_results.remove();
                    }
                    if (!that.multiple) that.$menu.find('.selected').addClass('active');
                    setTimeout(function() {
                        that.$searchbox.focus();
                    }, 10);
                });

                this.$searchbox.on('input propertychange', function() {
                    if (that.$searchbox.val()) {
                        that.$lis.not('.is-hidden').removeClass('hide').find('a').not(':icontains(' + that.$searchbox.val() + ')').parent().addClass('hide');

                        if (!that.$menu.find('li').filter(':visible:not(.no-results)').length) {
                            if (!!no_results.parent().length) no_results.remove();
                            no_results.html(that.options.noneResultsText + ' "'+ that.$searchbox.val() + '"').show();
                            that.$menu.find('li').last().after(no_results);
                        } else if (!!no_results.parent().length) {
                            no_results.remove();
                        }

                    } else {
                        that.$lis.not('.is-hidden').removeClass('hide');
                        if (!!no_results.parent().length) no_results.remove();
                    }

                    that.$menu.find('li.active').removeClass('active');
                    that.$menu.find('li').filter(':visible:not(.divider)').eq(0).addClass('active').find('a').focus();
                    $(this).focus();
                });

                this.$menu.on('mouseenter', 'a', function(e) {
                    that.$menu.find('.active').removeClass('active');
                    $(e.currentTarget).parent().not('.disabled').addClass('active');
                });

                this.$menu.on('mouseleave', 'a', function() {
                    that.$menu.find('.active').removeClass('active');
                });
            },

            val: function(value) {

                if (value !== undefined) {
                    this.$element.val( value );

                    this.$element.change();
                    return this.$element;
                } else {
                    return this.$element.val();
                }
            },

            selectAll: function() {
                if (this.$lis == null) this.$lis = this.$menu.find('li');
                this.$element.find('option:enabled').prop('selected', true);
                $(this.$lis).filter(':not(.disabled)').addClass('selected');
                this.render(false);
            },

            deselectAll: function() {
                if (this.$lis == null) this.$lis = this.$menu.find('li');
                this.$element.find('option:enabled').prop('selected', false);
                $(this.$lis).filter(':not(.disabled)').removeClass('selected');
                this.render(false);
            },

            keydown: function(e) {
                var $this,
                    $items,
                    $parent,
                    index,
                    next,
                    first,
                    last,
                    prev,
                    nextPrev,
                    that,
                    prevIndex,
                    isActive,
                    keyCodeMap = {
                        32:' ', 48:'0', 49:'1', 50:'2', 51:'3', 52:'4', 53:'5', 54:'6', 55:'7', 56:'8', 57:'9', 59:';',
                        65:'a', 66:'b', 67:'c', 68:'d', 69:'e', 70:'f', 71:'g', 72:'h', 73:'i', 74:'j', 75:'k', 76:'l',
                        77:'m', 78:'n', 79:'o', 80:'p', 81:'q', 82:'r', 83:'s', 84:'t', 85:'u', 86:'v', 87:'w', 88:'x',
                        89:'y', 90:'z', 96:'0', 97:'1', 98:'2', 99:'3', 100:'4', 101:'5', 102:'6', 103:'7', 104:'8', 105:'9'
                    };

                $this = $(this);

                $parent = $this.parent();

                if ($this.is('input')) $parent = $this.parent().parent();

                that = $parent.data('this');

                if (that.options.liveSearch) $parent = $this.parent().parent();

                if (that.options.container) $parent = that.$menu;

                $items = $('[role=menu] li:not(.divider) a', $parent);

                isActive = that.$menu.parent().hasClass('open');

                if (!isActive && /([0-9]|[A-z])/.test(String.fromCharCode(e.keyCode))) {
                    if (!that.options.container) {
                        that.setSize();
                        that.$menu.parent().addClass('open');
                        isActive = that.$menu.parent().hasClass('open');
                    } else {
                        that.$newElement.trigger('click');
                    }
                    that.$searchbox.focus();
                }

                if (that.options.liveSearch) {
                    if (/(^9$|27)/.test(e.keyCode) && isActive && that.$menu.find('.active').length === 0) {
                        e.preventDefault();
                        that.$menu.parent().removeClass('open');
                        that.$button.focus();
                    }
                    $items = $('[role=menu] li:not(.divider):visible', $parent);
                    if (!$this.val() && !/(38|40)/.test(e.keyCode)) {
                        if ($items.filter('.active').length === 0) {
                            $items = that.$newElement.find('li').filter(':icontains(' + keyCodeMap[e.keyCode] + ')');
                        }
                    }
                }

                if (!$items.length) return;

                if (/(38|40)/.test(e.keyCode)) {

                    index = $items.index($items.filter(':focus'));
                    first = $items.parent(':not(.disabled):visible').first().index();
                    last = $items.parent(':not(.disabled):visible').last().index();
                    next = $items.eq(index).parent().nextAll(':not(.disabled):visible').eq(0).index();
                    prev = $items.eq(index).parent().prevAll(':not(.disabled):visible').eq(0).index();
                    nextPrev = $items.eq(next).parent().prevAll(':not(.disabled):visible').eq(0).index();

                    if (that.options.liveSearch) {
                        $items.each(function(i) {
                            if ($(this).is(':not(.disabled)')) {
                                $(this).data('index', i);
                            }
                        });
                        index = $items.index($items.filter('.active'));
                        first = $items.filter(':not(.disabled):visible').first().data('index');
                        last = $items.filter(':not(.disabled):visible').last().data('index');
                        next = $items.eq(index).nextAll(':not(.disabled):visible').eq(0).data('index');
                        prev = $items.eq(index).prevAll(':not(.disabled):visible').eq(0).data('index');
                        nextPrev = $items.eq(next).prevAll(':not(.disabled):visible').eq(0).data('index');
                    }

                    prevIndex = $this.data('prevIndex');

                    if (e.keyCode == 38) {
                        if (that.options.liveSearch) index -= 1;
                        if (index != nextPrev && index > prev) index = prev;
                        if (index < first) index = first;
                        if (index == prevIndex) index = last;
                    }

                    if (e.keyCode == 40) {
                        if (that.options.liveSearch) index += 1;
                        if (index == -1) index = 0;
                        if (index != nextPrev && index < next) index = next;
                        if (index > last) index = last;
                        if (index == prevIndex) index = first;
                    }

                    $this.data('prevIndex', index);

                    if (!that.options.liveSearch) {
                        $items.eq(index).focus();
                    } else {
                        e.preventDefault();
                        if (!$this.is('.dropdown-toggle')) {
                            $items.removeClass('active');
                            $items.eq(index).addClass('active').find('a').focus();
                            $this.focus();
                        }
                    }

                } else if (!$this.is('input')) {

                    var keyIndex = [],
                        count,
                        prevKey;

                    $items.each(function() {
                        if ($(this).parent().is(':not(.disabled)')) {
                            if ($.trim($(this).text().toLowerCase()).substring(0,1) == keyCodeMap[e.keyCode]) {
                                keyIndex.push($(this).parent().index());
                            }
                        }
                    });

                    count = $(document).data('keycount');
                    count++;
                    $(document).data('keycount',count);

                    prevKey = $.trim($(':focus').text().toLowerCase()).substring(0,1);

                    if (prevKey != keyCodeMap[e.keyCode]) {
                        count = 1;
                        $(document).data('keycount', count);
                    } else if (count >= keyIndex.length) {
                        $(document).data('keycount', 0);
                        if (count > keyIndex.length) count = 1;
                    }

                    $items.eq(keyIndex[count - 1]).focus();
                }

                // Select focused option if "Enter", "Spacebar", "Tab" are pressed inside the menu.
                if (/(13|32|^9$)/.test(e.keyCode) && isActive) {
                    if (!/(32)/.test(e.keyCode)) e.preventDefault();
                    if (!that.options.liveSearch) {
                        $(':focus').click();
                    } else if (!/(32)/.test(e.keyCode)) {
                        that.$menu.find('.active a').click();
                        $this.focus();
                    }
                    $(document).data('keycount',0);
                }

                if ((/(^9$|27)/.test(e.keyCode) && isActive && (that.multiple || that.options.liveSearch)) || (/(27)/.test(e.keyCode) && !isActive)) {
                    that.$menu.parent().removeClass('open');
                    that.$button.focus();
                }

            },

            hide: function() {
                this.$newElement.hide();
            },

            show: function() {
                this.$newElement.show();
            },

            destroy: function() {
                this.$newElement.remove();
                this.$element.remove();
            }
        };

        $.fn.selectpicker = function(option, event) {
            //get the args of the outer function..
            var args = arguments;
            var value;
            var chain = this.each(function() {
                if ($(this).is('select')) {
                    var $this = $(this),
                        data = $this.data('selectpicker'),
                        options = typeof option == 'object' && option;

                    if (!data) {
                        $this.data('selectpicker', (data = new Selectpicker(this, options, event)));
                    } else if (options) {
                        for(var i in options) {
                            data.options[i] = options[i];
                        }
                    }

                    if (typeof option == 'string') {
                        //Copy the value of option, as once we shift the arguments
                        //it also shifts the value of option.
                        var property = option;
                        if (data[property] instanceof Function) {
                            [].shift.apply(args);
                            value = data[property].apply(data, args);
                        } else {
                            value = data.options[property];
                        }
                    }
                }
            });

            if (value !== undefined) {
                return value;
            } else {
                return chain;
            }
        };

        $.fn.selectpicker.defaults = {
            style: 'btn-default',
            size: 'auto',
            title: null,
            selectedTextFormat : 'values',
            noneSelectedText : 'Nothing selected',
            noneResultsText : 'No results match',
            countSelectedText: '{0} of {1} selected',
            maxOptionsText: ['Limit reached ({n} {var} max)', 'Group limit reached ({n} {var} max)', ['items','item']],
            width: false,
            container: false,
            hideDisabled: false,
            showSubtext: false,
            showIcon: true,
            showContent: true,
            dropupAuto: true,
            header: false,
            liveSearch: false,
            actionsBox: false,
            multipleSeparator: ', ',
            iconBase: 'glyphicon',
            tickIcon: 'glyphicon-ok',
            maxOptions: false
        };

        $(document)
            .data('keycount', 0)
            .on('keydown', '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role=menu], .bootstrap-select-searchbox input', Selectpicker.prototype.keydown)
            .on('focusin.modal', '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role=menu], .bootstrap-select-searchbox input', function (e) { e.stopPropagation(); });

    }(jQuery);
});
(function(win, undef) {

    win.SNI = win.SNI || { };

    win.boxContextLoaded(function(jQuery) {

        var DEBUG = win.SNI.BOX.DEBUG.forScope("UTIL");

        var $ = jQuery;

        // define appropriate configuration values in the site + environment config
        $.extend(true, win.SNI, {
            BOX: {
                Config: {
                    SocialUploader: {
                        pickOptions: {
                            multiple: false
                        }
                    }
                }
            },
            SocialUploader: {
                jQuery: jQuery
            }
        });

        // add functionality for social uploader into site namespace
        (function() {

            // Regex for extracting protocol & domain components of a URL
            var hostPattern = /^((?:(https?):)?(?:\/\/)?([^\/]+))/;

            /*
             Parameters:

             "url" - a URL from which the prefix should be extracted

             Returns:

             null if no prefix is contained with url, otherwise the protocol + domain portion of url
             */

            var getUrlPrefix = function(url) {

                var result = hostPattern.exec(url);
                return result === null ? null : result[1];
            };

            // account for triggering of the uploader before it's entirely loaded
            var preTriggerArgs = null;

            // pre-loaded definition of FDC.uploader simply stores the last-used args for later
            $.extend(true, win.SNI.BOX, {
                uploader: function(el) {

                    preTriggerArgs = arguments;
                }
            });

            if(win['BOX_SIMPLE_UPLOADER_URL'] === undef) {

                win.SNI.BOX.DEBUG("Cannot instantiate Simple Uploader without window.BOX_SIMPLE_UPLOADER_URL");
            } else {

                win.SNI.BOX.$LAB.script(win['BOX_SIMPLE_UPLOADER_URL'])
                        .wait(function() {

                    // wrap the full definition of FDC.uploader in the socialUploaderContextLoaded handler
                    win.socialUploaderContextLoaded(function() {

                        // define namespaced FDC.uploader method to invoke
                        $.extend(true, win.SNI.BOX, {
                            uploader: function(el, suPickOptions, suStoreOptions, suAssetMetaData) {

                                var $dfd = new $.Deferred();

                                var $el = $(el),
                                        pickOptions = SNI.BOX.Config.SocialUploader.pickOptions || {},
                                        storeOptions = SNI.BOX.Config.SocialUploader.storeOptions || {},
                                        assetMetaData = { };

                                if ($el.size() > 0) {

                                    // if a DOM element was provided, scrape parameters from data- attributes
                                    if ($el.data('suPickOptions') !== undef) {
                                        $.extend(true, pickOptions, $el.data('suPickOptions')); // data-su-pick-options
                                    }

                                    if ($el.data('suStoreOptions') !== undef) {
                                        $.extend(true, storeOptions, $el.data('suStoreOptions')); // data-su-store-options
                                    }

                                    if ($el.data('suAssetMetaData') !== undef) {
                                        $.extend(true, assetMetaData, $el.data('suAssetMetaData')); // data-su-asset-meta-data
                                    }
                                }

                                // override with method parameters
                                if (typeof suPickOptions === 'object') {
                                    $.extend(true, pickOptions, suPickOptions);
                                }

                                if (typeof suStoreOptions === 'object') {
                                    $.extend(true, storeOptions, suStoreOptions);
                                }

                                if (typeof suAssetMetaData === 'object') {
                                    $.extend(true, assetMetaData, suAssetMetaData);
                                }

                                DEBUG("Triggering box.beforeUpload: ", assetMetaData, pickOptions, storeOptions);
                                $(win.SNI.BOX).trigger('box.beforeUpload', [assetMetaData, pickOptions, storeOptions]);

                                CP_SERVICE_FILE_UPLOAD.uploadFile(function(data) {
                                    $dfd.resolve(data, pickOptions, storeOptions, assetMetaData);

                                }, function() {
                                    SNI.BOX.DEBUG("Social Upload ERROR callback triggered!");
                                    $dfd.fail();
                                }, assetMetaData, pickOptions, storeOptions);

                                return $dfd;
                            }
                        });

                        // the uploader was triggered but not fully loaded, load it now!
                        if (preTriggerArgs !== null) {
                            win.SNI.BOX.uploader.apply(null, preTriggerArgs);
                        }
                    });

                });

            }

        }());

        $.extend(true, win.SNI, {
            'BOX': {
                'Util': {

                    trackOmniture: function(data) {

                        win.SNI.BOX.DEBUG("trackOmniture called with data: ", data);

                        if(data === undef || data === null || data === '') {
                            data = { };
                        }

                        if(typeof data !== 'object') {
                            throw new Error("Illegal argument.");
                        }

                        var oldUniqueId = win.mdManager.getParameterString("UniqueId");
                        var uniqueIdParts = oldUniqueId.split("-");

                        if(uniqueIdParts < 3) {
                            throw new Error("\"" + oldUniqueId + "\" is not a valid UniqueId.");
                        }

                        if(data['assetId'] !== undef) {
                            uniqueIdParts[3] = data['assetId'];
                        }

                        if(data['contentType'] !== undef) {
                            uniqueIdParts[2] = data['contentType'];
                        }

                        if(data['mainAssetId'] !== undef) {
                            uniqueIdParts[1] = data['mainAssetId'];
                        }

                        win.mdManager.setParameter("UniqueId", uniqueIdParts.join('-'));

                        if(data['assetUrl'] !== undef) {
                            win.mdManager.setParameter("oUrl", win.mdManager.getParameterString("Url"));
                            win.mdManager.setParameter("Url", data['assetUrl']);
                        }

                        if(typeof s !== 'object' || typeof s['t'] !== 'function') {
                            throw new Error("Omniture tracking object ('s') is not defined");
                        }

                        s.t();

                        win.mdManager.setParameter("UniqueId", oldUniqueId);
                    },

                    alert: function(options) {
                        var defaults = {
                            message_html: "Unspecified message",
                            message_type: "success", // warning, error, or success
                            message_target: "mrb-primary-feedback",
                            action_type: "",
                            action_text: "",
                            action_url: "",
                            action_target: "",
                            action_button_class: "",
                            action_click_function: "",
                            data_action: "",
                            icon_class: "mrb-success-icon",
                            notification_display_class: "mrb-notification-display"
                        };

                        options = $.extend({}, defaults, options);

                        if (SNI.BOX.Util.isMobile() === true) {
                            SNI.BOX.DEBUG("Use mobile notifications");
                            options.message_target = "mrb-mobile-notification";
                        }

                        var action = "";
                        if (options.action_type != "") {

                            if (options.action_url !== "") {
                                action = "<a href='" + options.action_url + "' target='" + options.action_target + "' class='action " + options.action_type + "'>" + options.action_text + "</a>";
                            }
                            else if (options.action_click_function !== "") {
                                action = "<a href='javascript:;' target='" + options.action_target + "' onclick='" + options.action_click_function + "' class='action " + options.action_type + "'>" + options.action_text + "</a>";
                            }
                            else {
                                SNI.BOX.DEBUG("An action was added to an alert without an URL or Function");
                            }

                        }

                        if (options.data_action != "") {
                            action = "<a class='action undo recover-folder-item'>" + options.action_text + "</a>";
                        }

                        if (options.message_target === "mrb-primary-feedback") {

                            var $mrbpf = $("#mrb-primary-feedback");

                            if ($mrbpf.length < 1) {

                                $(".mrb-page-alert-container").append("<div id='mrb-primary-feedback' class='" + options.message_type + "'><span class='box-ss-check'></span><span class='message'>" + options.message_html + "</span>" + action + "</div>").show();

                            } else {

                                $mrbpf.removeClass().addClass(options.message_type).html("<span class='box-ss-check'></span><span class='message'>" + options.message_html + "</span>" + action).show();

                            }

                        }   else if (options.message_target === "mrb-mobile-notification") {

                            var notificationContainer = $("."+options.message_target);

                            win.SNI.BOX.DEBUG('triggering mobile notification...');

                            if(notificationContainer.length >= 1) {
                                win.SNI.BOX.DEBUG('found notification container, building notification html....');
                                var notificationDisplayClass = options.notification_display_class;
                                notificationContainer.removeClass(notificationDisplayClass);
                                //TODO: make this more elegant
                                notificationContainer.removeClass('mrb-loading-display');
                                notificationContainer.empty();

                                var notificationContent = $('<div />',
                                    { class : 'mrb-mobile-notification-top' });

                                var icon = $('<i />',
                                    {class : options.icon_class});

                                var message = $('<span />').html(options.message_html);

                                notificationContainer.append(notificationContent);
                                notificationContainer.append(action);
                                notificationContent.append(icon).append(message);

                                notificationContainer.addClass(notificationDisplayClass);
                            }
                        }   else {

                            win.SNI.BOX.DEBUG("alert", options);

                            $(options.message_target).empty().append("<div class='" + options.message_type + "'><span class='box-ss-check'></span><span class='message'>" + options.message_html + "</span>" + action + "</div>").show();

                        }

                        // Clicking outside the popups should close them all.
                        $(document).on('click scroll', function(event) {
                            win.SNI.BOX.Util.close_alert("#mrb-primary-feedback");
                        });

                    },
                    test_alert: function() {

                        win.SNI.BOX.Util.alert({
                            message_html: "Unspecified message Unspecified message Unspecified message Unspecified message",
                            message_type: "success", // warning, error, or success
                            message_target: "mrb-primary-feedback",
                            action_type: "undo",
                            action_text: "undo",
                            action_url: "#test-alert-action-url",
                            action_target: "",
                            action_click_function: "",
                            data_action: ""
                        });

                    },
                    createCookie: function(json) {
                        var domain = win.location;
                        if(domain){
                            $.cookie('mrb-message-alert', JSON.stringify(json), {expires: 1, path: '/', domain: win.SNI.BOX.Util.getDomain(win.location)});
                        }
                    },
                    destroyCookie: function() {
                        var domain = win.location;
                        if(domain){
                            $.removeCookie('mrb-message-alert', {path: '/', domain: win.SNI.BOX.Util.getDomain(win.location)});
                        }
                        $.removeCookie('mrb-message-alert');
                    },
                    displayCookieMessage: function() {
                        var messageObject = $.cookie('mrb-message-alert');
                        if (typeof messageObject === 'string' && messageObject.length > 0) {
                            var json = JSON.parse($.cookie('mrb-message-alert'));
                            if (json) {
                                win.SNI.BOX.Util.alert(json);
                                win.SNI.BOX.Util.destroyCookie(json);
                            }
                        }
                    },
                    close_alert: function(target) {
                        $(target).hide();
                    },
                    frameValidate: function(module, event) {
                        var isValidated = true;
                        module.find('[data-required="true"]').each(function() {
                            var $this = $(this);
                            if(!$this.val()){
                                $this.parent().addClass('has-error');
                                isValidated=false;
                            }
                        });
                        if(!isValidated) {
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                            event.preventDefault();
                        }
                    },
                    'isLocalStorageSupported': function() {
                        if(typeof win.localStorage === undefined) {
                            return false;
                        }
                        var test = 'boxTest';
                        try {
                            win.localStorage.setItem(test, test);
                            win.localStorage.removeItem(test);
                            return true;
                        } catch(e) {
                            return false;
                        }
                    },
                    'checkUserAgent': function(uaString) {
                        return new RegExp(uaString).test(navigator.userAgent) === true;
                    },

                    // Apple

                    'isIpad': function() {
                        return win.SNI.BOX.Util.checkUserAgent('iPad');
                    },
                    'isIphone': function() {
                        return win.SNI.BOX.Util.checkUserAgent('iPhone');
                    },
                    'isIOSMobile': function() {
                        return win.SNI.BOX.Util.isIphone();
                    },
                    'isIOS': function() {
                        return win.SNI.BOX.Util.isIOSMobile() || win.SNI.BOX.Util.isIpad();
                    },

                    // Android

                    'isAndroid': function() {
                        return win.SNI.BOX.Util.checkUserAgent('Android');
                    },
                    'isAndroidPhone': function() {
                        return win.SNI.BOX.Util.isAndroid() && (navigator.userAgent.toLowerCase().indexOf("mobile") !== -1);
                    },
                    'isAndroidTablet': function() {
                        return win.SNI.BOX.Util.isTouch() && win.SNI.BOX.Util.isAndroid() && (!/Mobile/i.test(navigator.userAgent) === true);
                    },

                    // Windows

                    'isMsieMobile': function() {
                        return win.SNI.BOX.Util.checkUserAgent('IEMobile/');
                    },

                    // General Detection

                    'isMobile': function() {
                        return win.SNI.BOX.Util.isIOSMobile() || win.SNI.BOX.Util.isAndroidPhone() || win.SNI.BOX.Util.isMsieMobile();
                    },

                    'isTouch': function() {
                        return 'ontouchstart' in win || 'onmsgesturechange' in win || !!(navigator.msMaxTouchPoints);
                    },
                    'isTablet': function() {
                        return win.SNI.BOX.Util.isTouch() === true && (win.SNI.BOX.Util.isAndroid() || win.SNI.BOX.Util.isIOS()) && !win.SNI.BOX.Util.isMobile();
                    },

                    'isPortraitOrientation': function() {
                        return win.outerWidth < win.outerHeight;
                    },
                    'isLandscapeOrientation': function() {
                        return win.outerWidth > win.outerHeight;
                    }
                }
            }
        });
    });

})(window, undefined);
window.boxContextLoaded(function(jQuery) {

    var $ = jQuery;

    var MODULE_DEBUG = SNI.BOX.DEBUG.forScope('SAVE_BUTTON_MODULE', 'PHOTO_BOX_MODULES');

    // unauthenticated version of the save button module
    // renders a fake link that triggers the AIM modal on click

    var unauthModule = SNI.BOX.plugin({

    }, function(plugin, options) {

        var $module = $(this);

        MODULE_DEBUG("calling unauth module init function");

        plugin.persist = function() {

            plugin.dfd().then(function() {

                $module.closest('[data-box-id]')
                    .addClass('box-state-note-display')
                    .addClass(options.persistenceClass);
            });
        };

        plugin.unPersist = function() {

            if(plugin.allowUnPersist() === true) {

                plugin.dfd().then(function() {

                    $module.closest('[data-box-id]')
                        .removeClass('box-state-note-display')
                        .removeClass(options.persistenceClass);

                });
            }
        };

        plugin.allowUnPersist = function() {
            return true;
        };
    });

    unauthModule.addRenderer(function(data, plugin, options, renderCompleteDfd) {

        var $root = $(this);

        $root.find('.box-default-html').remove();

        var $quickSaveButton = $root.find('.' + options.saveButtonClass);
        if($quickSaveButton.size() === 0) {
            $quickSaveButton = $('<div />', {
                'class': options.saveButtonClass + ' box-action'
            });
            $root.append($quickSaveButton);
        }

        var $quickSaveButtonSleeve = $quickSaveButton.find('.box-action-sleeve');
        if($quickSaveButtonSleeve.size() === 0) {
            $quickSaveButtonSleeve = $('<div />', {
                'class': 'box-action-sleeve'
            });
            $quickSaveButton.append($quickSaveButtonSleeve);
        }

        MODULE_DEBUG("calling auth module renderer", arguments);

        var $quickSaveButtonActiveState = $quickSaveButton.find('.box-action-icon.box-action-quick-save.' + options.activeClass);
        if($quickSaveButtonActiveState.size() === 0) {
            $quickSaveButtonActiveState = $('<a />', {
                'class': options.activeClass + ' box-action-icon box-action-quick-save',
                'href': options['boxHost']
            });
            $quickSaveButtonSleeve.append($quickSaveButtonActiveState);
        }

        var $quickSaveLink = $quickSaveButton.find('.box-action-icon.box-action-quick-save').not('.' + options.activeClass);
        // create a $quickSaveLink if none exists
        if($quickSaveLink.size() === 0) {
            $quickSaveLink = $('<a />', {
                'class': 'box-action-icon box-action-quick-save',
                'click': function() {

                    SNI.BOX.AUTH.getSchemeByName(options.authSchemeName).requireLogin({
                        'triggeredAssetId': options['assetId'],
                        'caller': 'savePhotoButton'
                    });
                    return false;
                }
            });
            $quickSaveButtonSleeve.append($quickSaveLink);
        }

        if(options.showCollectionSaveButton === true) {

            var $collectionButton = $root.find('.' + options.collectionSaveButtonClass);
            if($collectionButton.size() === 0) {

                $collectionButton = $('<div />', {
                    'class': options.collectionSaveButtonClass + ' box-action'
                });
                $root.append($collectionButton);
            }

            var $collectionButtonSleeve = $collectionButton.find('.box-action-sleeve');
            if($collectionButtonSleeve.size() === 0) {
                $collectionButtonSleeve = $('<div />', {
                    'class': 'box-action-sleeve'
                });
                $collectionButton.append($collectionButtonSleeve);
            }

            var $collectionButtonActiveState = $collectionButton.find('.box-action-icon.' + options.activeClass);
            if($collectionButtonActiveState.size() === 0) {
                $collectionButtonActiveState = $('<div />', {
                    'class': options.activeClass + ' box-action-icon'
                });
                $collectionButtonSleeve.append($collectionButtonActiveState);
            }

            var $collectionButtonLink = $collectionButton.find('.box-action-icon').not('.' + options.activeClass);
            if($collectionButtonLink.size() === 0) {
                $collectionButtonLink = $('<a />', {
                    'class': 'box-action-icon',
                    'click': function() {

                        SNI.BOX.AUTH.getSchemeByName(options.authSchemeName).requireLogin({
                            'invokeMethod': 'triggerAddToCollectionPopup',
                            'triggeredAssetId': options['assetId'],
                            'caller': 'savePhotoButton'
                        });
                        return false;
                    }
                });
                $collectionButtonSleeve.append($collectionButtonLink);
            }
        }
    });

    // authenticated version of the save button module
    // renders a quick save link and a save-to-collection link

    var authModule = SNI.BOX.plugin({

        'showCollectionSaveButton': true,
        'showNoteButton': false

    }, function(plugin, options) {

        var i,
            instanceData = null,
            collectionDeactivationTimer = null,
            $module = $(this),
            persistTimer = null,
            hoverIntentTimer = null,
            notificationTimer = null;

        $module.addClass('dari-frame');
        $module.attr('data-refresh-href', options.url);

        plugin.dfd().then(function() {
            //persist items on tablet
            if(SNI.BOX.Util.isTablet() === true) {
                plugin.persist();
            }
        });

        plugin.setData = function(data) {

            instanceData = data;
        };

        // ALWAYS wrap calls to plugin.getData in plugin.dfd().then(...)
        plugin.getDataDfd = function() {

            return plugin.dfd().pipe(function() {
                return instanceData;
            });
        };

        plugin.persist = function() {

            plugin.dfd().then(function() {

                $module.closest('[data-box-id]')
                    .addClass('box-state-note-display')
                    .addClass(options.persistenceClass);
            });
        };

        plugin.unPersist = function() {

            plugin.dfd().then(function() {

                if(plugin.allowUnPersist() === true) {
                    $module.closest('[data-box-id]')
                        .removeClass('box-state-note-display')
                        .removeClass(options.persistenceClass);
                }
            });
        };

        plugin.allowUnPersist = function() {
            //return !SNI.BOX.Util.isTablet();
            return true;
        };

        plugin.getSaveButton = function() {
            return $module.find('.' + options.saveButtonClass);
        };

        plugin.getFolderList = function() {

            return plugin.getSaveButton().find('.' + options.folderListClass);
        };

        plugin.getCollectionSaveButton = function() {
            return $module.find('.' + options.collectionSaveButtonClass);
        };

        plugin.getNotification = function() {
            return $module.find('.' + options.notificationClass);
        };

        plugin.activateSaveButton = function() {
            var $saveButton = plugin.getSaveButton();
            if($saveButton.size() > 0 && !$saveButton.hasClass(options.selectedClass)) {
                setTimeout(function() {
                    $saveButton.addClass(options.selectedClass);
                }, 50);
            }
        };

        plugin.activateCollectionSaveButton = function() {

            if(collectionDeactivationTimer !== null) {
                clearTimeout(collectionDeactivationTimer);
                collectionDeactivationTimer = null;
            }

            plugin.getCollectionSaveButton().addClass(options.selectedClass);
        };

        plugin.deactivateCollectionSaveButton = function(delay, force) {

            if(plugin.getCollectionSaveButton().hasClass(options.selectedClass)) {

                if(collectionDeactivationTimer !== null) {

                    if(force) {
                        MODULE_DEBUG("aborting deactivation of collection save button!");
                        clearTimeout(collectionDeactivationTimer);
                        collectionDeactivationTimer = null;
                    } else {
                        return;
                    }
                }

                MODULE_DEBUG("deactivating collection save button in " + delay + " ms");

                collectionDeactivationTimer = setTimeout(function() {
                    MODULE_DEBUG("deactivated collection save button");
                    plugin.getCollectionSaveButton().filter('.' + options.selectedClass).removeClass(options.selectedClass);
                    collectionDeactivationTimer = null;

                }, delay);
            }
        };

        plugin.triggerSave = function() {

            plugin.getDataDfd().then(function(data) {
                if(typeof data !== 'object') {

                    MODULE_DEBUG("ERROR [mrb-module-save-button.js]: Could not save, no data available!");
                    return;
                }

                if(data['isSaved'] === true) {

                    MODULE_DEBUG("INFO [mrb-module-save-button.js]: Asset is already saved!");
                }

                plugin.getSaveButton().find('.box-action-icon.box-action-quick-save').not(options.activeClass).click();
            });
        };

        plugin.triggerAddToCollectionPopup = function() {

            plugin.getDataDfd().then(function(data) {

                if(typeof data !== 'object') {

                    MODULE_DEBUG("ERROR [mrb-module-save-button.js]: Could not trigger addToCollectionPopup, no data available!");
                    return;
                }

                plugin.getCollectionSaveButton().find('.box-action-icon').not('.' + options.activeClass).click();
            })
        };

        plugin.notifySave = function(folderId, folderName, folderUrl) {

            var confirmationText = options['confirmationPrefix'] + ' ',
                $notification,
                href,
                text,
                target,
                $folderLink;

            setTimeout(function() {
                $module.find('.' + options.saveButtonClass).addClass(options.selectedClass);
            }, options.saveButtonActivationDelay);

            // TODO figure out a way to make this configuration-driven for mobile
            if(plugin.options().showNotifications === false || SNI.BOX.Util.isMobile()) {
                return;
            }

            // construct and display the notification

            plugin.persist();

            $notification = plugin.getNotification(); // should be font-size @ type scale = -1

            if($notification.size() === 0) {
                $notification = $('<div />', {
                    'class': options.notificationClass + ' box-hud box-hud-text'
                });
            }

            $notification.addClass(options.selectedClass).empty();

            $notification.text(confirmationText);

            href = !folderUrl ? SNI.BOX.Util.getByPath(options, 'defaultFolderLink/href') : folderUrl;

            text = !folderName ? SNI.BOX.Util.getByPath(options, 'defaultFolderLink/text') : folderName;

            target = SNI.BOX.Util.getByPath(options, 'defaultFolderLink/target');

            if(target === null) {
                target = "_top";
            }

            $folderLink = $('<a />', {
                'href': href,
                'target': target,
                'text': text
            });

            $notification.append($folderLink);

            $module.append($notification);

            plugin.deactivateCollectionSaveButton(options.collectionButtonDeactivationDelay, true);

            plugin.showTutorial();

            notificationTimer = setTimeout(function() {
                $notification.removeClass(options.selectedClass);
            }, options.notificationTimeout);

            hoverIntentTimer = setTimeout(function() {
                plugin.unPersist()
            }, Math.max(options.saveButtonActivationDelay, options.notificationTimeout));
        };

        plugin.showTutorial = function() {

            var tutorialModuleId = options.tutorialModule['_ref'];

            if(tutorialModuleId && $('[data-box-id="' + tutorialModuleId + '"]').size() === 0) {
                SNI.BOX.loadModule(tutorialModuleId);
            }
        };

        plugin.showFolderList = function() {

            var $folderList = plugin.getFolderList();

            if($folderList.hasClass('box-show') === false) {
                $folderList.addClass('box-show');
            }
        };

        plugin.hideFolderList = function() {

            var $folderList = plugin.getFolderList();

            if($folderList.hasClass('box-show')) {
                $folderList.removeClass('box-show');
            }
        };

        plugin.updateFolderList = function(folderId, folderName, folderUrl, isSaved) {

            if(folderId && folderName && folderUrl) {


                /* TODO: also update new mobile select element */

                var $folderList = $module.find('.' + options.folderListClass);
                var $folderListItem = $folderList.find('.' + options.folderListItemClass + '[itemid="' + folderId + '"]');
                if($folderListItem.size() === 0) {

                    $folderListItem = $('<div />', {
                        'class': options.folderListItemClass,
                        'itemid': folderId
                    });

                    var $folderLink = $('<a />', {
                        'href': folderUrl,
                        'text': folderName,
                        'target': '_top'
                    });

                    $folderListItem.append($folderLink);

                    var i;
                    var $folderListItems = $folderList.find('.' + options.folderListItemClass);

                    if($folderListItems.size() === 0) {
                        $folderList.append($folderListItem);
                    } else {
                        // splice into the existing list in alphabetical order
                        for(i = 0; i < $folderListItems.size(); i += 1) {
                            if(i === $folderListItems.size() - 1) {
                                $folderList.append($folderListItem);
                            } else if(i === 0) {
                                if(folderName < $folderListItems.eq(0).find('a').text()) {
                                    $folderList.prepend($folderListItem);
                                }
                            } else {
                                if(folderName >= $folderListItems.eq(i-1).find('a').text() && folderName <= $folderListItems.eq(i).find('a').text()) {
                                    $folderListItem.insertAfter($folderListItems.eq(i-1));
                                    break;
                                }
                            }
                        }
                    }
                }

                if(isSaved === true) {
                    $folderList.removeClass(options.disabledClass);
                    $folderListItem.addClass('box-show');
                }
            }
        };

        plugin.getNoteOverlay = function() {
            return $module.find('.' + options.noteOverlayClass);
        };

        plugin.getShowNoteButton = function() {
            return $module.find('.' + options.showNoteButtonClass);
        };

        plugin.getAddNoteButton = function() {
            return $module.find('.' + options.addNoteButtonClass);
        };

        plugin.updateNoteDisplay = function(text) {

            var newNote = text || "";

            var $noteOverlay = plugin.getNoteOverlay();
            if($noteOverlay.size() > 0) {
                var $noteDisplay = $noteOverlay.find('.' + options.noteDisplayClass);

                if($noteDisplay.size() > 0) {
                    $noteDisplay.text(text);
                }

                var $addNoteButton = plugin.getAddNoteButton();
                var $showNoteButton = plugin.getShowNoteButton();

                if(newNote.length > 0) {

                    // disable the $addNoteButton if enabled
                    if($addNoteButton.hasClass(options.disabledClass) === false) {
                        $addNoteButton.addClass(options.disabledClass);
                        plugin.showNote();
                    }

                    // disable the $showNoteButton if enabled
                    if($showNoteButton.hasClass(options.disabledClass) === false) {
                        $showNoteButton.addClass(options.disabledClass);
                    }

                } else {

                    // disable the $showNoteButton if enabled
                    if($showNoteButton.hasClass(options.disabledClass) === false) {
                        $showNoteButton.addClass(options.disabledClass);
                    }

                    // enable the $addNoteButton if disabled
                    if($addNoteButton.hasClass(options.disabledClass)) {
                        $addNoteButton.removeClass(options.disabledClass);
                    }

                    plugin.hideNote();
                }
            }
        };

        plugin.showNote = function() {

            var $showNoteButton = plugin.getShowNoteButton();
            var $noteOverlay = plugin.getNoteOverlay();
            var $addNoteButton = plugin.getAddNoteButton();

            if($noteOverlay.size() > 0) {

                // $addNoteButton exists and is displaying
                if($addNoteButton.size() === 0 || $addNoteButton.hasClass(options.disabledClass) === true) {

                    plugin.persist();

                    $showNoteButton.addClass(options.disabledClass);
                    $noteOverlay.removeClass(options.disabledClass);
                }
            }
            return true;
        };

        plugin.hideNote = function() {

            var $showNoteButton = plugin.getShowNoteButton();
            var $noteOverlay = plugin.getNoteOverlay();
            var $addNoteButton = plugin.getAddNoteButton();

            if($noteOverlay.size() > 0) {

                // $addNoteButton exists and is displaying
                if($addNoteButton.size() === 0 || $addNoteButton.hasClass(options.disabledClass) === true) {

                    plugin.unPersist();

                    $showNoteButton.removeClass(options.disabledClass);
                    $noteOverlay.addClass(options.disabledClass);

                } else if($showNoteButton.size() === 0 || $showNoteButton.hasClass(options.disabledClass) === true) {

                    plugin.unPersist();

                    $addNoteButton.removeClass(options.disabledClass);
                    $noteOverlay.addClass(options.disabledClass);
                }
            }
            return true;
        };

        var handleSavedAsset = function(e, data) {
            MODULE_DEBUG("entering handler for [savedAsset]");
            var containsAsset = false;
            var i;

            if(data['asset']['id'] === options['assetId']) {

                containsAsset = true;

            } else if(Array.isArray(data['asset']['externalId'])) {

                for(i = 0; i < data['asset']['externalId'].length; i += 1) {

                    var externalId = data['asset']['externalId'][i];
                    var rawExternalId = externalId.substr(externalId.indexOf("/") + 1);

                    if(rawExternalId === options['assetId']) {
                        containsAsset = true;
                        break;
                    }
                }
            }

            var folder = data['folder'];

            if(typeof folder === 'object') {

                plugin.updateFolderList(folder['id'], folder['title'], folder['href'], containsAsset);
                hgtvStyleRenderer.apply($module, [data, plugin, options]);
                //TODO: this can't be hard-coded
                if(containsAsset === true) {
                    plugin.notifySave(folder['id'], folder['title'], folder['href']);
                }
            } else {
                if(containsAsset === true) {
                    plugin.notifySave();
                }
            }

            if(containsAsset === true && options.showQuickEditLink === true) {
                setTimeout(function() {
                    plugin.getSaveButton().addClass(options.superActionActiveClass);
                }, options.quickEditActivationDelay);
            }
        };

        var handleEditedFolderItem = function(e, data) {

            MODULE_DEBUG("entering handler for [editedFolderItem]");
            var containsAsset = false;
            var i;
            var noteData = data['folderItem']['userNote'];

            if(!noteData) {
                //TODO: remove when fully tested
                MODULE_DEBUG("[save-button.js : handleEditedFolderItem]: blank userNote");
                //return;
            }

            if(data['asset']['id'] === options['assetId']) {

                containsAsset = true;
            } else if(Array.isArray(data['asset']['externalId'])) {

                for(i = 0; i < data['asset']['externalId'].length; i += 1) {

                    var externalId = data['asset']['externalId'][i];
                    var rawExternalId = externalId.substr(externalId.indexOf('/') + 1);

                    if(rawExternalId === options['assetId']) {
                        containsAsset = true;
                        break;
                    }
                }
            }

            if(containsAsset === true) {

                plugin.updateNoteDisplay(noteData);
            }
        };

        // display folder list on hover of the save button (when not in super-action-active (3rd) state)



        /* TODO: start ifNotMobile check - handles hover to show / hide the folder list */

        $module.on('hover', '.' + options.saveButtonClass + ', .' + options.folderListClass, function(e) {

            var $button = $(this);

            if(e.type === 'mouseenter') {

                if($button.hasClass(options.superActionActiveClass)) {

                    return;
                }

                plugin.showFolderList();
                plugin.persist();

                if(hoverIntentTimer !== null) {

                    window.clearTimeout(hoverIntentTimer);
                    hoverIntentTimer = null;
                }

            } else if(e.type === 'mouseleave') {

                if(hoverIntentTimer !== null) {

                    window.clearTimeout(hoverIntentTimer);
                    hoverIntentTimer = null;
                }

                hoverIntentTimer = setTimeout(function() {

                    plugin.hideFolderList();
                    plugin.unPersist();
                    hoverIntentTimer = null;

                }, options.hoverIntentDelay);
            }

        });

        /* TODO: end ifNotMobile check */

        $module.on('hover',  '.' + options.collectionSaveButtonClass + ', .' + options.editNoteButtonClass + ', .' + options.notificationClass, function(e) {

            if(e.type === 'mouseenter') {

                if(hoverIntentTimer !== null) {

                    window.clearTimeout(hoverIntentTimer);
                    hoverIntentTimer = null;
                }

                hoverIntentTimer = setTimeout(function() {

                    plugin.hideFolderList();
                    hoverIntentTimer = null;

                }, options.hoverIntentDelay);

                plugin.persist();

            } else if(e.type === 'mouseleave') {

                if(hoverIntentTimer !== null) {

                    window.clearTimeout(hoverIntentTimer);
                    hoverIntentTimer = null;
                }

                hoverIntentTimer = setTimeout(function() {

                    plugin.hideFolderList();
                    plugin.unPersist();
                    hoverIntentTimer = null;

                }, options.hoverIntentDelay);
            }
        });

        $('body')
            .on('hide.bs.modal', options.modalSelector, function() {
                plugin.deactivateCollectionSaveButton(options.collectionButtonCancelDeactivationDelay)
            })
            .on('savedAsset', handleSavedAsset)
            .on('editedFolderItem', options.savePhotoModuleSelector, handleEditedFolderItem)
            .on('showNote', plugin.showNote)
            .on('hideNote', plugin.hideNote);
    });

    authModule.addRenderer(function(data, plugin, options, renderCompleteDfd) {

        plugin.dfd().then(function() {
            plugin.setData(data);
        });
    });

    authModule.addRenderer(function(data, plugin, options, renderCompleteDfd) {

        MODULE_DEBUG("calling auth module renderer", arguments);

        var authScheme = SNI.BOX.AUTH.getSchemeByName(options.authSchemeName);
        var authSchemeName = authScheme != null ? authScheme.getName() : null;

        var $root = $(this);

        $root.find('.box-default-html').remove();

        var $quickSaveButton = $root.find('.' + options.saveButtonClass);
        if($quickSaveButton.size() === 0) {
            $quickSaveButton = $('<div />', {
                'class': options.saveButtonClass + ' box-action'
            });
            $root.append($quickSaveButton);
        }

        var $quickSaveButtonSleeve = $quickSaveButton.find('.box-action-sleeve');
        if($quickSaveButtonSleeve.size() === 0) {
            $quickSaveButtonSleeve = $('<div />', {
                'class': 'box-action-sleeve'
            });
            $quickSaveButton.append($quickSaveButtonSleeve);
        }

        if(options.showQuickEditLink === true) {

            $quickSaveButtonSleeve.addClass(options.hasSuperActionClass);

            var $quickEditLink = $quickSaveButton.find('.box-action-icon.box-action-quick-edit');
            // create a $quickEditLink if none exists
            if($quickEditLink.size() === 0) {
                $quickEditLink = $('<a />', {
                    'class': 'box-action-icon box-action-quick-edit',
                    'href': '#',
                    'click': function(event) {

                        event.preventDefault();
                        SNI.BOX.loadModule(options['savePhotoModule']['_ref'], JSON.stringify({
                            'photoId': options['assetId'],
                            'isModal': true,
                            'showConfirmation': false,
                            'modalSize': 'modal-lg',
                            'action': 'lookup',
                            'authSchemeName': authSchemeName
                        }));
                    }
                });
                $quickSaveButtonSleeve.append($quickEditLink);
            }
        }

        var $quickSaveButtonActiveState = $quickSaveButton.find('.box-action-icon.box-action-quick-save.' + options.activeClass);
        if($quickSaveButtonActiveState.size() === 0) {
            $quickSaveButtonActiveState = $('<a />', {
                'class': options.activeClass + ' box-action-icon box-action-quick-save',
                'href': options['boxHost'],
                'target': '_top'
            });
            $quickSaveButtonSleeve.append($quickSaveButtonActiveState);
        }

        var $quickSaveLink = $quickSaveButton.find('.box-action-icon.box-action-quick-save').not('.' + options.activeClass);
        // create a $quickSaveLink if none exists
        if($quickSaveLink.size() === 0) {
            $quickSaveLink = $('<a />', {
                'class': 'box-action-icon box-action-quick-save',
                'href': authScheme.signUrl(options['boxApiUrlPrefix'] + '/item/save?assetId=' + options['assetId'] + '&includeFolders=true'),
                'click': function() {
                    plugin.ready().then(plugin.activateSaveButton)
                }
            });
            $quickSaveButtonSleeve.append($quickSaveLink);
        }

        var $folderList = $quickSaveButton.find('.' + options.folderListClass);
        // generate a $folderList if none exists
        if($folderList.size() === 0) {
            $folderList = $('<div />', {
                'class': options.folderListClass + ' ' + options.disabledClass
            });

            var $folderListTitle = $('<div />', {
                'class': options.folderListTitleClass,
                'text': options['folderListTitle']
            });

            $folderList.append($folderListTitle);
            $quickSaveButton.append($folderList);
        }

        /* TODO: also build select element */

        if(data[options['assetId']]['isSaved'] === true) {

            /* TODO: also populate select element options */

            // add the "box-selected" class to the $quickSaveLink if the asset is saved
            $quickSaveButton.addClass(options.selectedClass);

            if(options.showQuickEditLink === true && plugin.firstRender()) {
                $quickSaveButton.addClass(options.superActionActiveClass);
            }

            // remove previously generated $folderListItem nodes
            $folderList.find('.' + options.folderListItemClass).remove();

            // reset the $folderList's disabled status
            $folderList.addClass(options.disabledClass);

            var folders = data[options['assetId']]['folders'];

            if(folders !== null && typeof folders === 'object' && Array.isArray(folders) && folders.length > 0) {

                var i;
                var inFolderCount = 0;

                // re-generate all $folderListItem nodes
                for(i = 0; i < folders.length; i += 1) {

                    var folder = folders[i];

                    var $folderListItem = $('<div />', {
                        'class': options.folderListItemClass,
                        'itemid': folder['_id']
                    });

                    var $folderLink = $('<a />', {
                        'href': folder['url'],
                        'text': folder['title'],
                        'target': '_top'
                    });

                    if(folder['inFolder'] === true) {
                        inFolderCount += 1;
                        $folderListItem.addClass(options.showClass);
                    }

                    $folderListItem.append($folderLink);

                    $folderList.append($folderListItem);
                }

                if(inFolderCount > 0) {
                    $folderList.removeClass(options.disabledClass);
                }
            }
        }

        var $collectionButton = $root.find('.' + options.collectionSaveButtonClass);

        if(options.showCollectionSaveButton === true) {

            if($collectionButton.size() === 0) {

                $collectionButton = $('<div />', {
                    'class': options.collectionSaveButtonClass + ' box-action'
                });
                $root.append($collectionButton);
            }

            var $collectionButtonSleeve = $collectionButton.find('.box-action-sleeve');
            if($collectionButtonSleeve.size() === 0) {
                $collectionButtonSleeve = $('<div />', {
                    'class': 'box-action-sleeve'
                });
                $collectionButton.append($collectionButtonSleeve);
            }

            var $collectionButtonActiveState = $collectionButton.find('.box-action-icon.' + options.activeClass);
            if($collectionButtonActiveState.size() === 0) {
                $collectionButtonActiveState = $('<div />', {
                    'class': options.activeClass + ' box-action-icon'
                });
                $collectionButtonSleeve.append($collectionButtonActiveState);
            }

            var $collectionButtonLink = $collectionButton.find('.box-action-icon').not('.' + options.activeClass);
            if($collectionButtonLink.size() === 0) {
                $collectionButtonLink = $('<a />', {
                    'class': 'box-action-icon',
                    'href': '#',
                    'click': function(event) {

                        event.preventDefault();

                        plugin.ready().then(plugin.activateCollectionSaveButton)
                        SNI.BOX.loadModule(options['addToCollectionModule']['_ref'], JSON.stringify({
                            "photoId": options['assetId'],
                            "isModal": true,
                            "showConfirmation": false,
                            "action": "lookup",
                            "authSchemeName": authSchemeName
                        }));
                    }
                });
                $collectionButtonSleeve.append($collectionButtonLink);
            }
        }

        // business logic - if already saved & show notes button is set, hide the quick-save button
        // and show the notes button


        if(options.showNoteButton === true
            && data[options['assetId']]['isSaved'] === true
            && (options.showQuickEditLink !== true || plugin.firstRender() === true)) {

            $quickSaveButton.hide();
            $collectionButton.hide();

            var $noteButtonAdd = $root.find('.' + options.addNoteButtonClass);
            if($noteButtonAdd.size() === 0) {

                $noteButtonAdd = $('<div />', {
                    'class': 'box-note-button-add box-hud box-hud-text box-hud-text-action-link'
                });

                $root.append($noteButtonAdd);
            }

            var $noteButtonAddLink = $noteButtonAdd.find('.box-action-link');
            if($noteButtonAddLink.size() === 0) {
                $noteButtonAddLink = $('<a />', {

                    'class': 'box-action-link',
                    'href': '#',
                    'click': function(event) {
                        event.preventDefault();
                        SNI.BOX.loadModule(options['savePhotoModule']['_ref'], JSON.stringify({
                            'photoId': options['assetId'],
                            'isModal': true,
                            'showConfirmation': false,
                            'modalSize': 'modal-lg',
                            'action': 'lookup',
                            'authSchemeName': authSchemeName
                        }));
                    },
                    'text': options['addNoteText']
                });

                $noteButtonAdd.append($noteButtonAddLink);
            }

            var $noteButtonShow = $root.find('.' + options.showNoteButtonClass);
            if($noteButtonShow.size() === 0) {

                $noteButtonShow = $('<div />', {
                    'class': options.showNoteButtonClass + ' box-hud box-hud-text box-hud-text-action-link'
                });

                $root.append($noteButtonShow);
            }

            var $noteButtonShowLink = $noteButtonShow.find('.box-action-link');
            if($noteButtonShowLink.size() === 0) {
                $noteButtonShowLink = $('<a />', {
                    'class': 'box-action-link',
                    'href': '#',
                    'text': options['showNoteText'],
                    'click': function() {
                        var $this = $(this);
                        setTimeout(function() {
                            $this.trigger('showNote');
                        }, 0);

                        return false;
                    }
                });
                $noteButtonShow.append($noteButtonShowLink);
            }

            var $noteOverlay = $root.find('.' + options.noteOverlayClass);
            if($noteOverlay.size() === 0) {
                $noteOverlay = $('<div />', {
                    'class': options.noteOverlayClass
                });
                $root.append($noteOverlay);
            }

            var $closeNoteOverlay = $noteOverlay.find('.box-close');
            if($closeNoteOverlay.size() === 0) {
                $closeNoteOverlay = $('<a />', {
                    'href': '#',
                    'class': 'box-close icon icon-times',
                    'click': function() {
                        var $this = $(this);
                        setTimeout(function() {
                            $this.trigger('hideNote');
                        }, 0);
                        return false;
                    }
                });
                $noteOverlay.append($closeNoteOverlay);
            }

            var $noteDisplay = $root.find('.' + options.noteDisplayClass);
            if($noteDisplay.size() === 0) {
                $noteDisplay = $('<div />', {
                    'class': options.noteDisplayClass + ' modal-body',
                    'text': data[options['assetId']]['userNote']
                });
                $noteOverlay.append($noteDisplay);
            }

            var $noteEditFooter = $noteDisplay.find('.modal-footer');
            if($noteEditFooter.size() === 0) {
                $noteEditFooter = $('<div />', {
                   'class': 'modal-footer'
                });
                $noteOverlay.append($noteEditFooter);
            }

            var $noteEditLink = $noteDisplay.find('.' + options.editNoteButtonClass);
            if($noteEditLink.size() === 0) {
                $noteEditLink = $('<a />', {
                    'class': 'box-note-edit-link btn btn-default btn-sm',
                    'href': '#',
                    'click': function(event) {
                        event.preventDefault();
                        SNI.BOX.loadModule(options['savePhotoModule']['_ref'], JSON.stringify({
                            'photoId': options['assetId'],
                            'isModal': true,
                            'showConfirmation': false,
                            'modalSize': 'modal-lg',
                            'action': 'lookup',
                            'authSchemeName': authSchemeName
                        }));
                    },
                    'text': options['editNoteText']
                });
                $noteEditFooter.append($noteEditLink);
            }

            if($noteOverlay.hasClass(options.disabledClass) === false) {

                $noteButtonShow.addClass(options.disabledClass);

                if(data[options['assetId']]['userNote'] === null) {

                    $noteButtonAdd.removeClass(options.disabledClass);
                    $noteOverlay.addClass(options.disabledClass);

                } else {

                    $noteButtonAdd.addClass(options.disabledClass);

                    plugin.dfd().then(function() {
                        plugin.persist();
                    });
                }
            }
        }

        var $notification = $root.find('.' + options.notificationClass); // should be font-size @ type scale = -1

        if($notification.size() === 0) {
            $notification = $('<div />', {
                'class': options.notificationClass + ' box-hud box-hud-text'
            });

            $root.append($notification);
        }
    });

    var renderFakeHtml = function($el, options) {

        var $root = $el.find('.box-default-html');
        if($root.size() === 0) {
            $root = $('<div />', {
                'class': 'box-default-html'
            });
            $el.append($root);
        }

        var $quickSaveButton = $root.find('.' + options.saveButtonClass);
        if($quickSaveButton.size() === 0) {
            $quickSaveButton = $('<div />', {
                'class': options.saveButtonClass + ' box-action'
            });
            $root.append($quickSaveButton);
        }

        var $quickSaveButtonSleeve = $quickSaveButton.find('.box-action-sleeve');
        if($quickSaveButtonSleeve.size() === 0) {
            $quickSaveButtonSleeve = $('<div />', {
                'class': 'box-action-sleeve'
            });
            $quickSaveButton.append($quickSaveButtonSleeve);
        }

        MODULE_DEBUG("calling auth module renderer", arguments);

        var $quickSaveButtonActiveState = $quickSaveButton.find('.box-action-icon.box-action-quick-save.' + options.activeClass);
        if($quickSaveButtonActiveState.size() === 0) {
            $quickSaveButtonActiveState = $('<a />', {
                'class': options.activeClass + ' box-action-icon box-action-quick-save',
                'href': '#'
            });
            $quickSaveButtonSleeve.append($quickSaveButtonActiveState);
        }

        var $quickSaveLink = $quickSaveButton.find('.box-action-icon.box-action-quick-save').not('.' + options.activeClass);
        // create a $quickSaveLink if none exists
        if($quickSaveLink.size() === 0) {
            $quickSaveLink = $('<a />', {
                'class': 'box-action-icon box-action-quick-save',
                'click': function() {

                    return false;
                }
            });
            $quickSaveButtonSleeve.append($quickSaveLink);
        }

        if(options.showCollectionSaveButton === true) {

            var $collectionButton = $root.find('.' + options.collectionSaveButtonClass);
            if($collectionButton.size() === 0) {

                $collectionButton = $('<div />', {
                    'class': options.collectionSaveButtonClass + ' box-action'
                });
                $root.append($collectionButton);
            }

            var $collectionButtonSleeve = $collectionButton.find('.box-action-sleeve');
            if($collectionButtonSleeve.size() === 0) {
                $collectionButtonSleeve = $('<div />', {
                    'class': 'box-action-sleeve'
                });
                $collectionButton.append($collectionButtonSleeve);
            }

            var $collectionButtonActiveState = $collectionButton.find('.box-action-icon.' + options.activeClass);
            if($collectionButtonActiveState.size() === 0) {
                $collectionButtonActiveState = $('<div />', {
                    'class': options.activeClass + ' box-action-icon'
                });
                $collectionButtonSleeve.append($collectionButtonActiveState);
            }

            var $collectionButtonLink = $collectionButton.find('.box-action-icon').not('.' + options.activeClass);
            if($collectionButtonLink.size() === 0) {
                $collectionButtonLink = $('<a />', {
                    'class': 'box-action-icon',
                    'click': function() {

                        return false;
                    }
                });
                $collectionButtonSleeve.append($collectionButtonLink);
            }
        }
    };

    var photoSaveButtonModule = window.SNI.BOX.authenticatedPlugin({

        'reRender': true,
        'authOptions': { },
        'unauthOptions': { },
        'showCollectionSaveButton': true,
        'showNoteButton': false,
        'showQuickEditLink': false,
        'showNotifications': true,

        'saveButtonClass': 'box-save-button',
        'collectionSaveButtonClass': 'box-collection-save-button',

        'folderListClass': 'box-folder-list',
        'folderListItemClass': 'box-folder-list-item',
        'folderListTitleClass': 'box-folder-list-title',

        'noteOverlayClass': 'box-note-overlay',
        'noteDisplayClass': 'box-note-display',
        'showNoteButtonClass': 'box-note-button-show',
        'addNoteButtonClass': 'box-note-button-add',
        'editNoteButtonClass': 'box-note-button-edit',

        'notificationClass': 'box-notification',

        'disabledClass': 'box-disabled',
        'selectedClass': 'box-selected',
        'activeClass': 'box-active-state',
        'showClass': 'box-show',

        'hasSuperActionClass': 'box-has-super-action',
        'superActionActiveClass': 'box-super-action-active',

        'addToCollectionModuleSelector': '[itemtype~="com.scrippsnetworks.photos.AddToCollectionModule"]',
        'savePhotoModuleSelector': '[itemtype~="com.scrippsnetworks.photos.SavePhotoModule"]',

        'modalSelector': '#box-modal-container',

        'saveButtonActivationDelay': 500,
        'notificationTimeout': 5000,
        'collectionButtonDeactivationDelay': 500,
        'collectionButtonCancelDeactivationDelay': 500,
        'hoverIntentDelay': 700,
        'quickEditActivationDelay': 5000,

        'persistenceClass': 'box-state-persist-display'

    }, function(plugin, options) {

        var $module = $(this);

        var $unauthModuleRoot = $('<div />');
        $module.append($unauthModuleRoot);

        var authScheme = plugin.getAuthScheme();

        if(options['smartPhone'] === true) {

            renderFakeHtml($unauthModuleRoot, options);

            // kinda big hack, but need the styles on the root before the API call is made
            hgtvStyleRenderer.apply($unauthModuleRoot, [null, plugin, options, null]);
        }

        unauthModule.call($unauthModuleRoot, $.extend(true, { }, options, {
            'url': null,
            'initData': { },
            'authSchemeName': authScheme.getName()
        }), options.unauthOptions);

    }, function(plugin, options, triggered, thenOptions) {

        var $module = $(this);
        var $authModuleRoot = $('<div />');

        $module.append($authModuleRoot);

        if(options['smartPhone'] === true) {

            renderFakeHtml($authModuleRoot, options);

            // kinda big hack, but need the styles on the root before the API call is made
            hgtvStyleRenderer.apply($authModuleRoot, [null, plugin, options, null]);
        }

        var authScheme = plugin.getAuthScheme();

        var assetId = options['assetId'];

        authModule.call($authModuleRoot, $.extend(true, { }, options, {
            'url': authScheme.signUrl(SNI.BOX.Util.getUrlPrefix(window['BOX_SERVER_HOST']) + "/api/box/isSaved?assetId=" + options.assetId + "&includeFolders=true"),
            'authSchemeName': authScheme.getName(),
            'dataType': 'json',
            'sourceDataFormat': 'json',
            'jsonp': 'callback'
        }, options.authOptions));

        var authPluginInstance = $authModuleRoot.data('boxPlugin');

        MODULE_DEBUG("thenOptions:", thenOptions);

        if((options['triggered'] === true || triggered === true) && thenOptions && thenOptions['caller'] === 'savePhotoButton' && thenOptions['triggeredAssetId'] === assetId) {

            authPluginInstance.ready().then(function() {

                if(typeof thenOptions === 'object' && typeof thenOptions['invokeMethod'] === 'string' && typeof authPluginInstance[thenOptions['invokeMethod']] === 'function') {
                    authPluginInstance[thenOptions['invokeMethod']].call(plugin);
                } else {
                    // save regardless of whether the asset is already saved, because this action updates
                    // the asset's ordering in the database
                    authPluginInstance.triggerSave();
                }
            });
        }
    });

    photoSaveButtonModule.auth = authModule;
    photoSaveButtonModule.unauth = unauthModule;

    $.fn.boxSaveButtonModule = photoSaveButtonModule;

    var hgtvStyleRenderer = function(data, plugin, options, renderCompleteDfd) {

        MODULE_DEBUG("calling external renderer for auth module");

        var $root = $(this);

        if(options['smartPhone'] === true || SNI.BOX.Util.isMobile() === true) {
            $root.addClass('box-smart-phone');
        }

        // quick save button theme
        var $quickSaveButton = $root.find('.' + options.saveButtonClass);

        if($quickSaveButton.size() > 0) {

            $quickSaveButton.addClass('box-hud');

            var $quickSaveButtonLink = $quickSaveButton.find('.box-action-sleeve').children().filter('.box-action-icon.box-action-quick-save').not('.' + options.activeClass).first();
            $quickSaveButtonLink.addClass('icon icon-heart-o');

            var $quickSaveButtonActiveState = $quickSaveButton.find('.box-action-sleeve').children().filter('.box-action-icon.box-action-quick-save.' + options.activeClass).first();
            $quickSaveButtonActiveState.addClass('icon icon-heart-checked');

            var $quickEditLink = $quickSaveButton.find('.box-action-sleeve').children().filter('.box-action-icon.box-action-quick-edit').first();
            $quickEditLink.addClass('icon icon-pencil-square-o');
        }

        // collection save button theme
        var $collectionButton = $root.find('.' + options.collectionSaveButtonClass);
        $collectionButton.addClass('box-hud');

        if($collectionButton.size() > 0) {
            var $collectionButtonLink = $collectionButton.find('.box-action-sleeve').children().filter('.box-action-icon').not('.' + options.activeClass).first();
            $collectionButtonLink.addClass('icon icon-folder-open-o');

            var $collectionButtonActiveState = $collectionButton.find('.box-action-sleeve').children().filter('.box-action-icon.' + options.activeClass).first();
            $collectionButtonActiveState.addClass('icon icon-folder-open');
        }

        // note button theme
        var $noteButton = $root.find('.box-note-edit-button');
        $noteButton.addClass('box-hud box-hud-text');

        // folder list
        $root.find('.' + options.folderListItemClass).addClass('small font-weight-bold');
        $root.find('.' + options.folderListTitleClass).addClass('small font-weight-book');
        $root.find('.' + options.notificationClass).addClass('small');
    };

    photoSaveButtonModule.auth.addRenderer(hgtvStyleRenderer);

    photoSaveButtonModule.unauth.addRenderer(hgtvStyleRenderer);
});
window.boxContextLoaded(function (jQuery) {
    var $ = jQuery;

    window.SNI.BOX.addToCollectionModule = window.SNI.BOX.plugin({

        }, function (plugin, options) {

            var $module = $(this);

            $module.find('select').selectpicker(SNI.BOX.Util.isMobile() === true ? 'mobile' : '');

            var isCreateCollectionEnabled = false;

            plugin.enableCreateCollection = function() {

                if(isCreateCollectionEnabled === true) {
                    return;
                }

                var $source = $module.find('[data-action="enableCreateCollection"]'),
                    $sourceFormGroup = $source.next('.form-group'),
                    $input = $sourceFormGroup.find('input'),
                    $select = $module.find('select'),
                    $selectFormGroup = $select.closest('.form-group');

                // update state
                isCreateCollectionEnabled = true;

                // visual changes
                $source.addClass('hide');
                $sourceFormGroup.removeClass('hide');
                $input.focus();

                // set validation requirements
                $input.attr('data-required', 'true');
                $select.attr('data-required', 'false');

                // remove error states
                $sourceFormGroup.add($selectFormGroup).removeClass('has-error');

                // reset form fields
                $select.selectpicker('deselectAll');
            };

            plugin.disableCreateCollection = function() {

                if(isCreateCollectionEnabled === false) {
                    return;
                }

                var $source = $module.find('[data-action="enableCreateCollection"]'),
                    $sourceFormGroup = $source.next('.form-group'),
                    $input = $sourceFormGroup.find('input'),
                    $select = $module.find('select'),
                    $selectFormGroup = $select.closest('.form-group');

                // update state
                isCreateCollectionEnabled = false;

                // visual changes
                $source.removeClass('hide');
                $sourceFormGroup.addClass('hide');

                // set validation requirements
                $input.attr('data-required', 'false');
                $select.attr('data-required', 'true');

                // remove error states
                $sourceFormGroup.add($selectFormGroup).removeClass('has-error');

                // reset form fields
                $sourceFormGroup.find('input[type="text"]').val('');
            };

            $module
            .on("enableCreateCollection", plugin.enableCreateCollection)
            .on('frame.validate', function(event) {
                window.SNI.BOX.Util.frameValidate($module, event);
            })
            .on('click', '.bootstrap-select', plugin.disableCreateCollection)
            .on('change', 'select', function() {
                var $select = $(this);
                if($.trim($select.val()) !== '') {
                    $select.closest('.form-group').removeClass('has-error');
                }
            })
            .on('keyup', 'input[type="text"]', function() {
                var $input = $(this);
                if($.trim($input.val()) !== '') {
                    $input.closest('.form-group').removeClass('has-error');
                }
            });


            $('body').on('closeModal', '[itemtype~="com.scrippsnetworks.photos.AddToCollectionModule"]', function() {

                var $modal = $('#box-modal-container');
                if($modal.find('[itemtype~="com.scrippsnetworks.photos.AddToCollectionModule"]').size() > 0) {
                    SNI.BOX.DEBUG("[add-to-collection.js]: closing modal");
                    $modal.modal('hide');
                }
            });
        });

    $.fn.boxAddToCollectionModule = window.SNI.BOX.addToCollectionModule;
    window.jQuery.fn.boxAddToCollectionModule = window.SNI.BOX.addToCollectionModule;
});
window.boxContextLoaded(function(jQuery) {

    var $ = jQuery;

    var photosTutorialModule = window.SNI.BOX.plugin({}, function(plugin, options) {
        var $module  = $(this);

        SNI.BOX.DEBUG("Initializing Tutorial module...");

        $(function(){

            var slider_options = {
                arrowsNav: false,
                allowCSS3: false,
                transitionSpeed:400,
                arrowsNavAutoHide: false,
                fadeinLoadedSlide: false,
                controlNavigationSpacing: 0,
                controlNavigation: 'bullets',
                imageScaleMode: 'none',
                imageAlignCenter:false,
                blockLoop: true,
                loop: false,
                numImagesToPreload: 6,
                transitionType: window.SNI.BOX.Util.isMobile() === true ? 'move' : 'fade',
                keyboardNavEnabled: true
            };


            var boxTutorialSlider = $module.find('.box-tutorial-slider');

            if(boxTutorialSlider.size() > 0) {
                boxTutorialSlider.recipeBoxRoyalSlider( slider_options );
                var rsNav = boxTutorialSlider.find('.rsNav');
                $('.box-tutorial-nav').append(rsNav);
                boxTutorialSlider.closest('.box-tutorial').css('visibility', 'visible');

                var sliderData = boxTutorialSlider.data('royalSlider');
                sliderData.ev.on('rsBeforeAnimStart', function(event){
                    var slideIndex = sliderData.currSlideId;
                    var boxTutorialNav = $('.box-tutorial-nav');
                    if(slideIndex == 0){
                        boxTutorialNav.addClass('box-tutorial-first-slide');
                        boxTutorialNav.removeClass('box-tutorial-last-slide');
                    } else {
                        boxTutorialNav.removeClass('box-tutorial-first-slide');
                    }

                    if(slideIndex === (sliderData.numSlides -1)){
                        boxTutorialNav.addClass('box-tutorial-last-slide');
                        boxTutorialSlider.attr('data-dismiss', 'modal');
                    } else{
                        boxTutorialNav.removeClass('box-tutorial-last-slide');
                        boxTutorialSlider.attr('data-dismiss', '');
                    }
                });
            }

            $('body')
                .on('click', '.box-tutorial-skip, .box-tutorial-finish', function(event){
                    event.preventDefault();
                    //CLOSE MODAL
                })
                .on('click', '.box-tutorial-next, .box-tutorial-start', function(event){
                    event.preventDefault();
                    sliderData.next();
                })
                .on('click', '.box-tutorial-prev', function(event){
                    event.preventDefault();
                    sliderData.prev();
                });
        });

        $('body').on('loadModule', '[itemtype~="com.scrippsnetworks.photos.PhotosTutorialModule"]', function(e, data) {
            SNI.BOX.DEBUG("[LOAD MODULE] for photo tutorial", data);
            SNI.BOX.loadModule(data['moduleId'], data);
        });
    });

    $.fn.boxPhotosTutorialModule = photosTutorialModule;
});
